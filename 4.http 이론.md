# HTTP 이론

---



#### webStudy 레파지토리의 webCS 정리를 참고하며 복습하자



개발자는 평생 HTTP 기반위에서 개발한다. 언젠가 한번은 정리할 필요가 있다.

## [목차]

[인터넷 네트워크](#인터넷-네트워크)

> basic CS

[웹 브라우저 요청흐름](#웹-브라우저-요청흐름-URI(Uniform-Resource-Identifier))

> URL

[HTTP란](#HTTP)

> HTTP의 기초

[HTTP 메서드](#HTTP-메서드)

> GET POST ..

[HTTP 상태코드](#HTTP-상태코드)

> 404,504 ..







# 인터넷 네트워크

---

![인터넷 프로토콜 계층](https://user-images.githubusercontent.com/68331041/127839070-ba11b2ef-8be4-4af8-816c-b7ee79a4cec2.PNG)

* **프로토콜::** 복수의 컴퓨터 사이나 중앙 컴퓨터와 단말기 사이에서 데이터 통신을 원활하게 하기 위해 필요한 통신 규약. 신호 송신의 순서, **데이터의 표현법**, 오류(誤謬) 검출법 등을 정함.

![프로토콜 계층](https://user-images.githubusercontent.com/68331041/127839078-a3196b84-b7b4-45ea-b3b3-2c96eda6c78c.PNG)

+ 각 계층에서 필요 정보를 패킷을 패키징하여 넘겨줌



## OS계층 프로토콜**(TCP,IP)**

---

+ SOCKET으로 부터 받은 데이터를 TCP/UDP 프로토콜에서  패키징하여  포트 정보(아파트 동 호수)를 주입하고 IP 프로토콜에서 IP주소(아파트 이름)를 주입하여 서버로 전송한다.



## IP(인터넷 프로토콜)

+ 출발지 IP, 목적지 IP 패키징

> 출발 IP와 도착 IP를 가지고 데이터를 던져서 여러 인터넷 망을 거쳐 다니며 도착지를 찾아 패킷을 전달한다.
>
> **문제:** 따라서 도착IP가 **존재하지 않아도 패킷이 전송**되며, 중간에 거쳐가던 망이 문제가 생기면 **데이터 중도 손실**될 위험이 있으며, 패킷마다 도착IP를 발견할 속도가 다르기 때문에 **순서에 맞지않게 패킷들이 도착** 할 수 도있다.

## TCP/UDP(전송 제어 프로토콜)

#### **인터넷 프로토콜의 문제점을 해결**

+ 출발지 PORT, 목적지 PORT
  전송 제어, 순서, 검증 정보 패키징

> **TCP**
>
> > **3 way handshake**(SYN(접속 요청) 을 보내고 서버가 ACK(요청 수락) )을 통해 **연결을 먼저 확인**하고 패킷을 전송하며 서버와 전송된 데이터를 가지고 소통하며 **데이터 전송과 순서를 보장**한다
> >
> > > 참고:  ACK와 함께 데이터 전송 가능
> 
> **UDP**
>
> > 기능이 거의 없음 도화지 같은 프로토콜
>>
> > 사용자 정의적 프로토콜로 입맛에 맞추어서 최적화 하여 사용한다.
> 
> ### PORT란
>
> + 아파트가 IP라면 포트는 동+호 로 세부 주소
>
> > 여러 서버와 연결되는경우 **같은 IP 내에서 프로세스 구분하여 관리**하도록 함
>>
> > 유튜브 게임 통화 등등 동시작업할때





# 웹 브라우저 요청흐름 URI(Uniform Resource Identifier)

---



+ 리소스 식별 통합방법
+ URI? URL? URN?
+ URI는 URL(로케이터(locator)), URN(이름(name))로 분류될 수 있다

> 리소스의 위치와 리소스 이름
>
> **URN 이름만으로 실제 리소스를 찾을 수 있는 방법이 보편화 되지 않음**

![URI](https://user-images.githubusercontent.com/68331041/127839067-6c5385df-5396-4a7e-ad13-b07e4895e2f0.PNG)

## URI는   URL과 같은 의미로 봐도 무방하다! 올바른 URL설계가 필요하다.



## URL전체 문법

ex)
https://www.google.com:443/search?q=hello&hl=ko

> **프로토콜**(https)
>
> > **프로토콜**: 어떤 방식으로 자원에 접근할 것인가 하는 약속 규칙
> > 예) http, https, ftp 등등
> > http는 80 포트, https는 443 포트를 주로 사용, 포트는 생략 가능
> > https는 http에 보안 추가 (HTTP Secure)
>
> **호스트명**(www.google.com)
>
> > 호스트명
> > **도메인명(DNS) 또는 IP 주소**를 직접 사용가능
> >
> > > 구글 or www.google.com
>
> **포트** **번호**(443)
>
> > 일반적으로 생략
>
> **패스**(/search)
>
> > 리소스 경로(path), 계층적 구조
>
> **쿼리** **파라미터**(q=hello&hl=ko)
>
> > key=value 형태
> > **?**로 시작, **&**로 추가 가능 ?keyA=valueA&keyB=valueB
> > query parameter, query string 등으로 불림, 웹서버에 제공하는 **파라미터**, 문자 형태
>
> **fragment**
>
> > html 내부 북마크 등에 사용(한 화면에서 이동 마크)
> > 서버에 전송하는 정보 아님



## 웹 브라우저 요청 흐름

![전송 흐름도](https://user-images.githubusercontent.com/68331041/127839074-adb3578b-068f-473b-bcda-62ca0a5bba84.PNG)

### + 브라우저에서 HTTP 데이터 생성, 소켓라이브러리를 통해  OS단위의 TCP/IP(프로토콜)로 전달  패키징 후 서버로 패킷전송

### + 서버에서 데이터를 분석 ,알맞는 데이터를 찾아서 클라이언트에게 전송





# HTTP

---

### + + *HTTP*는  리소스들을 가져올 수 있도록 해주는 프로토콜(데이터 양식)입니다. 

**HTTP 메시지에 모든 것을 전송**
• HTML, TEXT
• IMAGE, 음성, 영상, 파일
• JSON, XML (API)
• 거의 모든 형태의 데이터 전송 가능
• 서버간에 데이터를 주고 받을 때도 대부분 HTTP 사용
• 지금은 HTTP 시대!

**기반 프로토콜**
• TCP: HTTP/1.1, HTTP/2
• UDP: HTTP/3



# HTTP는



### 클라이언트 서버 구조를 따른다

Request Response 구조
• 클라이언트는 서버에 요청을 보내고, 응답을 대기
• 서버가 요청에 대한 결과를 만들어서 응답

클라이언트와 서버가 독립적으로 동작하며 각자 동작에 집중할수있다.



### 무상태 프로토콜( 서버는 Stateless(무상태) 로 관리해야한다.)이다.

**서버가 클라이언트의 상태를 보존X**

• 장점: 서버 확장성 높음(스케일 아웃)
• 단점: 클라이언트가 추가 데이터 전송

**Stateful, Stateless 차이**

> **상태 유지:** 중복되는 정보를 서버에게 기억하게 한다.
>
> > **중간에 서버가 터지면? 문제발생 항상 같은 서버가 유지되어야 한다.**
>
> **무상태:** 클라이언트가 정보를 끝까지 모두 가지고 있다
>
> > **아무 서버나 호출해도 된다**
> >
> > ### [핵 중요!!!]
> >
> > • 갑자기 클라이언트 요청이 증가해도 서버를 대거 투입할 수 있다.
> > • 무상태는 응답 서버를 쉽게 바꿀 수 있다. -> **무한한 서버 증설 가능**


**실무 한계**

> • 모든 것을 무상태로 설계 할 수 있는 경우도 있고 없는 경우도 있다.
>
> • 무상태 예) 로그인이 필요 없는 단순한 서비스 소개 화면
>
> • 상태 유지 예) 로그인
>
> • 로그인한 사용자의 경우 로그인 했다는 상태를 서버에 유지
>
> • 일반적으로 **브라우저 쿠키와 서버 세션등을 사용해서 상태 유지기능을 구현한다**
>
> • **상태 유지는 최소한만 사용**





## 비연결성이다

**HTTP는 기본이 연결을 유지하지 않는 모델**

• 일반적으로 초 단위의 이하의 빠른 속도로 응답

• 1시간 동안 수천명이 서비스를 사용해도 실제 서버에서 동시에 처리하는 요청은 수십개 이
하로 매우 작음

• 연결을 바로바로 끊기 때문에 서버 자원을 매우 효율적으로 사용할 수 있음

**단점**

> **매번 TCP/IP 연결을 새로 맺어야 함** - 3 way handshake 시간 추가
>
> 웹 브라우저로 사이트를 요청하면 매번 HTML 뿐만 아니라 자바스크립트, css, 추가 이미지 등
> 등 수 많은 자원이 함께 다운로드
>
> 지금은 **HTTP 지속 연결**(Persistent Connections)로 **문제 해결**
>
> HTTP/2, HTTP/3에서 **더 많은 최적화**

### [핵중요!!]

* **HTTP 지속 연결**

  > 초기에 한 페이지를 보이기위해 HTML 뿐만 아니라 자바스크립트, css, 추가 이미지 등 
  >
  > 각각의 리소스당 연결->해제를 반복하였으나
  >
  > > 예를들면 HTML 받고 연결해제 -> HTML 작업중 CSS필요 -> 다시연결 ->해제 ->CSS작업중 JS필요
  > >
  > > ->다시연결 ->해제
  >
  > **전체 리소스가 모두 받아질때까지만 연결을 유지해두는 지속연결을 사용하여 비연결성의 문제를 개선**
  >
  > > 연결 -> HTML~JS모두 다운받을때까지 연결유지 -> 해제



### 서버는 항상 무상태와 비연결성을 가져야 한다!





## HTTP 메세지



**HTTP 메세지 구조**

~~~python
HTTP-message = start-line  #1. 시작라인
 			*( header-field CRLF ) #2. 헤더
			 CRLF #3.공백라인 (필수)
			 [ message-body ] #4.메세지 바디
~~~

4계층으로 나누어진 공식 스펙



**1.시작 라인**

> HTTP 메서드 (GET: 조회)
>
> > **GET** /search?q=hello&hl=ko HTTP/1.1
> >
> > 종류: GET, POST, PUT, DELETE
> >
> > GET: 리소스 조회
> > POST: 요청 내역 처리
>
> 요청 대상 (/search?q=hello&hl=ko)
>
> > GET /search?q=hello&hl=ko **HTTP/1.1**
> >
> > 절대경로= "/" 로 시작하는 경로
>
> HTTP Version
>
> > GET /search?q=hello&hl=ko **HTTP/1.1**

**2.헤더**

> HTTP **전송에 필요한 모든 부가정보**
>
> 메시지 바디의 내용, 메시지 바디의 크기, 압축, 인증, 요청 클라이언트(브라우저) 정보, 
> 서버 애플리케이션 정보, 캐시 관리 정보...

**3.공백라인 (필수)**

> 한칸 띄고

**4.메시지 바디**

> HTML 문서, 이미지, 영상, JSON 등등 byte로 표현할 수 있는 모든 데이터
>
> 실제 전송할 데이터





## 즉, URL은 웹  리소스에 접근하고자 찾아가는 길을 의미하며, HTTP는 인터넷에서 데이터를 주고받는 프로토콜이다.

> HTTPS를 사용하면 암호화 하여 데이터를 보낼수있다. 
>
> 인증된 기관에서만 HTTPS를 사용할수있다.





# HTTP 메서드

---



## HTTP API 설계

URI는 리소스만 식별! 

• **리소스와 해당 리소스를 대상으로 하는 행위을 분리**

> 회원을 등록하고 수정하고 조회하는게 리소스가 아니다!
>
> **회원이라는 개념 자체가 바로 리소스다**. 

• 리소스: 회원

• 행위: 조회, 등록, 삭제, 변경에 따라 **HTTP메서드로 행위 분리**



## HTTP 메서드

**주요 메서드**

### • **GET**: 리소스 조회

> 서버에 전달하고 싶은 데이터는 
>
> #### **URL query(쿼리 파라미터, 쿼리 스트링)를 통해서 전달**
>
> 
>
> **메시지 바디를 사용해서 데이터를 전달**할 수 있지만, **지원하지 않는 곳이 많아서 권장하지 않음**
>
> 이미 있는 정보를 조회할때 주로 사용한다.
>
> GET으로 온 경우 서버는 캐싱을 한다.

### • **POST**: 요청 데이터 처리, 주로   "등록" 에 사용,  리소스 생성 

> #### **메시지 바디를 통해** **서버로 요청 데이터 전달**
>
> 서버는 데이터를 처리하는 모든 기능을 수행한다
>
> 서버에 큰 변화가 생기는 경우 POST를 쓴다
>
> 새로운 데이터를 서버에 저장시킬때 주로 사용한다 ex)게시물 등록

### • **PUT**: 리소스를 대체, 해당 리소스가 없으면 생성

> 리소스가 있으면 **완전 대체** 리소스가 없으면 생성 쉽게 이야기해서 덮어버림
>
> 클라이언트가 리소스 위치를 알고 URI 지정

### • **PATCH**: 리소스 부분 변경

> 기존 리소스를 완전삭제하고 보낸 리소스로 완전 대체 되어버리는 PUT과 달리 
>
> 기존 리소스 부분을 변경한다.
>
> 지원하지 않는 경우가 있다.

### • **DELETE**: 리소스 삭제



## POST는 무적이다. 위 메소드를 모두 대체하여 사용할수있다.



**기타 메서드**
• HEAD: GET과 동일하지만 메시지 부분을 제외하고, 상태 줄과 헤더만 반환
• OPTIONS: 대상 리소스에 대한 통신 가능 옵션(메서드)을 설명(주로 CORS에서 사용)
• CONNECT: 대상 자원으로 식별되는 서버에 대한 터널을 설정
• TRACE: 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트를 수행



## HTTP 메서드의 속성

![HTTP 메서드 속성](https://user-images.githubusercontent.com/68331041/127839058-27468b74-1817-470c-825d-c12e4298165c.PNG)

**안전**(Safe Methods)

> 호출해도 리소스를 변경하지 않는다.

**멱등**(Idempotent Methods)

> 연산을 여러 번 적용하더라도 결과가 달라지지 않는 성질 1X1=1
>
> 한 번 호출하든 두 번 호출하든 100번 호출하든 결과가 똑같다
>
> [멱등O]
>
> GET: 한 번 조회하든, 두 번 조회하든 같은 결과가 조회된다.
> PUT: 결과를 대체한다. 따라서 같은 요청을 여러번 해도 최종 결과는 같다.
> DELETE: 결과를 삭제한다. 같은 요청을 여러번 해도 삭제된 결과는 똑같다.
>
> [멱등X]
>
> **POST: 멱등이 아니다! 두 번 호출하면 같은 결제가 중복해서 발생할 수 있다**

**캐시가능**(Cacheable Methods)

> 응답 결과 리소스를 캐시해서 사용해도 되는가?
>
> GET



## HTTP 메서드 활용



### **클라이언트에서 서버로 데이터 전송**
데이터 전달 방식은 크게 2가지

> **• 쿼리 파라미터를 통한 데이터 전송**
> 	• GET
> 	• 주로 정렬 필터(검색어)
>
> **• 메시지 바디를 통한 데이터 전송**
> 	• POST, PUT, PATCH
> 	• 회원 가입, 상품 주문, 리소스 등록, 리소스 변경

### **클라이언트에서 서버로 데이터 전송**

4가지 상황

> ### **• 정적 데이터 조회**(파라미터 **불필요**)
>
> ​	 	이미지, 정적 텍스트 문서
>
> ### **• 동적 데이터 조회**(파라미터 **필요**)
>
> ​		주로 검색, 게시판 목록에서 정 렬 필터(**검색어**)
>
> ### **• HTML Form을 통한 데이터 전송**
>
> ​		회원 가입, 상품 주문, 데이터 변경
>
> ​		**GET & POST만 지원한다.**
>
> ​		**주의!** GET은 조회에만 사용! 
>
> ​		리소스 변경이 발생하는 곳에 사용하면 안됨!
>
> ​		POST는 메세지 바디에 데이터를 보내 주지만 **GET은 URL에 쿼리 파라미터에    		데이터를 담아서 보낸다.** **외부로 노출**되기때문에 POST를 써야한다. 
>
> ### **• HTTP API를 통한 데이터 전송**
>
>  		**HTML FORM을 사용하지않고** 데이터를 전송함
>
> ​		회원 가입, 상품 주문, 데이터 변경
> ​		**서버 to 서버**, 앱 클라이언트, **웹 클라이언트**(Ajax)
>
> ​		예) **React, VueJs 같은 웹 클라이언트와 API 통신**



#### GET은 URL에 데이터를 받아 전송하며 POST는 HTTP메시지 바디에 데이터를 받아서 전송한다. 따라서 GET은 전달되는 데이터가 URL에 그대로 표기되며 POST는 표기되지 않는다.

> GET도 메시지 바디에 보낼수있으나 지원되는 곳이 많지 않기 때문에 사용하지 X



# HTTP 상태코드

---

## 상태 코드
**클라이언트가 보낸 요청의 처리 상태를 응답에서 알려주는 기능**

• 1xx (Informational): 요청이 수신되어 처리중
• 2xx (Successful): 요청 정상 처리
• 3xx (Redirection): 요청을 완료하려면 추가 행동이 필요

> 구 URL 에서 신 URL로 바뀐경우 구 URL을 입력하면 서버가 신 URL 정보를 응답해
>
> 클라이언트가 자동으로 리다이렉트 해서 재요청하도록 하여 자동으로 신 URL로 이동한다.

• 4xx (Client Error): 클라이언트 오류, 잘못된 문법등으로 서버가 요청을 수행할 수 없음
• 5xx (Server Error): 서버 오류, 서버가 정상 요청을 처리하지 못함





