# 예외처리의 ''기본''

---

예외처리 시리즈를 다루다가 좀 더 본질적인 부분에 내가 무심했다는것을 깨달았다.

> 에러, 에러의 종류 ,계층 구조 등등



**이번 포스트는 그 `기본`을 다시 공부한것을 정리해두고자 한다.**



### 프로그램 오류란?

프로그램이 실행 중 어떤 원인에 의해서 오작동을 하거나 비정상 종료되는 경우를 초래하는 원인을 프로그램 `에러 또는 오류`라고한다.



이 오류는 3가지 종류로 크게 구분할수있다.

~~~
컴파일 에러 - 컴파일 시점에 발생하는 에러

런타임 에러 - 실행 시에 발생하는 에러

논리적 에러 - 실행은 되지만 잘못 작성된 로직으로 인해 의도와 다르게 동작하는 것
~~~



### 예외란?

`자바`같은 `컴파일 언어`는 컴파일러가 컴퓨터가 알아들을수있도록 개발자 코드를 기계어로 번역하는데,  

이때, `컴파일 에러`는 컴파일시에 컴파일러가 소스코드(.java) 에 대하여 `오타`, `잘못된 구문` , `자료형 체크` 등을 수행하여 오류가 있는지 알려준다.

하지만 컴파일 에러가 발생하지 않았다고 모든 에러가 대비된것은 아니다.

실제로 프로그램은 `잠재적인 오류`에 대한 위험이 존재하기때문에 실행시점에 갑자기 `런타임 에러`를 발생시킬수있다.

따라서 이런 런타임 에러에 대한 `경우의 수를 예측`하고 그에 상응하는 `대비`가 필요하다.

`자바는` 런타임중 발생할수있는 에러를 `처리가능 여부`에 따라 `에러` 와 `예외`로 `구분`한다. 

> 여기서 `에러는` 스택오버플로우 , 메모리 부족 등 대응 불가능한 `심각한 오류`를 지칭한다.
>
> 반면 `예외는` 개발자가 코드를 미리 작성함으로써 프로그램의 비정상 종료를 막을수있는 `경미한 오류`를 지칭한다.





### 예외 클래스 

자바에서는 런타임에 발생할수있는 `오류`를 클래스로 정의하였다.

> Exceptions 와 Errors 클래스로 구분하고있다.



모든 클래스의 최고 조상 Object를 Exceptions 와 Errors 도 상속하고있다.

![image](C:\Users\afrad\OneDrive\바탕 화면\java_image_120.png)

> Throwable 의 getMessage()를 통해 Exception 인스턴스에 저장된 message를 받을수있다.
>
> ~~~ java
> try{
>     throw new Exception("Message");
> }catch(Exception e){
>     log.info(e.getMessage()); //"Message"
> }
> ~~~



**Exception 클래스**

모든 예외의 최고 조상은 Exception 클래스이다.

Exception 클래스 하위에는 많은 예외 클래스들이 존재하는데, 이 예외 클래스들은 아래와 같이 2개의 그룹으로 구분된다.

![image](C:\Users\afrad\OneDrive\바탕 화면\java_image_121.png)

~~~
- Exception 클래스와 그 하위 예외 클래스들 (여기서 RuntimeException 클래스와 그 하위는 제외)

- RuntimeException 클래스와 그 하위 예외 클래스들
~~~



**Exception 클래스와 그 하위 예외 클래스들 (여기서 RuntimeException 클래스와 그 하위는 제외)**

+ 사용자의 실수와 같은 외적인 요인에 의해 발생하는 예외

> ex) 존재하지 않는 파일의 이름을 입력(FileNotFoundException),
>
> 실수로 클래스의 이름을 잘못 적음(ClassNotFoundException),
>
> 입력한 데이터 형식이 잘못됨(DataFormatException)



**RuntimeException 클래스와 그 하위 예외 클래스들**

+ 프로그래머의 실수로 발생하는 예외

> ex) 배열의 범위를 벗어남(IndexOutOfBoundsException),
>
> 값이 null인 참조변수의 멤버를 호출(NullPointerException),
>
> 클래스간의 형변환을 잘못함(ClassCastException),
>
> 정수를 0으로 나누려고 시도(ArithmeticException)





### CHECKED vs UNCHECKED

컴파일러가 에러처리를 확인하지 않는 RuntimeException 클래스들은 unchecked 예외라고 부르고 예외처리를 확인하는 Exception 클래스들은 checked 예외라고 부른다.



**체크 예외(Checked Exception)**

체크 예외는 RuntimeException의 하위 클래스가 아니면서 Exception 클래스의 하위 클래스들을 으미. 

`체크 예외의 특징은 반드시 에러 처리를 해야하는 특징(try/catch or throw)`을 가지고 있다.

- `존재하지 않는 파일의 이름을 입력(FileNotFoundException)`
- `실수로 클래스의 이름을 잘못 적음(ClassNotFoundException)`

 



**언체크 예외(Unchecked Exception)**

언체크 예외는 RuntimeException의 하위 클래스들을 의미. 

이것은 체크 예외와는 달리 에러 처리를 강제하지 않는다. 말 그대로 `실행 중에(runtime)` 발생할 수 있는 예외를 의미.

- `배열의 범위를 벗어난(ArrayIndexOutOfBoundsException)`
- `값이 null이 참조변수를 참조(NullPointerException)`



**언체크 예외(Unchecked Exception)의 예외 처리를 강제하지 않는 이유**

배열의 범위가 벗어나면 발생하는 `ArrayIndexOutOfBoundsException` 으로 예를 들어보자면 이는 개발자가 배열을 다루는것에 실수가 있어서 발생할것이다.

개발자의 실수에 의해 발생하는 예외까지 처리를 강제하게 되면 단순히 배열을 선언하는 코드에도 `try ~ catch` 문이 작성되어야한다.

개발자가 예외를 확인하고 코드를 수정함으로써 처리되어질수있기때문에 예외처리 코드를 강제하지 않는것이다.



<img src="C:\Users\afrad\OneDrive\바탕 화면\105691015-0d436b80-5f40-11eb-994d-58c55b8d47b8.png" alt="image" style="zoom: 80%;" />





### 예외 던지기

~~~java
void Excep() throws Exception {
    //메서드 내용..
}
~~~

자바는 메서드 내부에서 예외를 발생시키거나 발생할 가능성이 있는 경우 선언부에 명시하여 메서드를 사용하는 쪽에서 이에 대한 처리를 시사하고 그에 따라 더 견고한 프로그램이 완성되도록 한다.





### 사용자 정의 예외 만들기

기존의 정의된 예외 클래스 외에 필요한 경우에 따라 `개발자가 직접 예외 클래스를 만들고 기능들을 추가해두고 사용`한다.

**`Exception 나 RuntimeException를 상속`받아 정의한다.**

> CHECKED 나 UNCHECKED



어떤 클래스를 상속했냐에 따라 예외처리의 `강제 여부`가 결정된다.



**`* 요즘엔` Exception이 아닌 `RuntimeException을 상속`시켜서 예외처리를 선택적으로(unchecked) 할 수 있도록 한다.**



getErrcode() 와 같이 기존의 예외 클래스가 제공하는 기능이 아니라 `개발자가 필요한 기능을 추가`할수있다.

~~~java
class MyException extends RuntimeException{
    
    private String Errcode; //에러코드 라는 정보를 추가
    
    MyException(String msg,String Errcode){
        super(msg);
        this.Errcode = Errcode;
    }
    
    public String getErrcode(){ //이 메서드는 RuntimeException의 getMessage()와 함께 쓰일것이다.
        return Errcode;
    }   
}
~~~





### 예외처리 잘하는 방법

`사용자 정의 예외` 는 이름만으로 어떤 예외인지 파악할수있도록 정의 되어야하며 예외를 발생시키면서 상황을 알려주고, 예외 처리를 위한 충분한 처리 정보를 제공하는 `로그`를 반드시 함께 남겨야 한다.

