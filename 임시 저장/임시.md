# 임시









# 요구사항 변동 이슈(feat.MappingJacksonValue)

---

### 개요

초기에 설계가 변경됨에 따라  발생하는 문제가 또 발생했다.

> 사실 이번엔 요구사항이 바뀐거지만..



물론 이 프로젝트는 <u>제로 베이스 부터 시작</u>했기때문에 처음부터 <u>설계가 완벽할수는 없었겠지만</u> 다시한번 정확한 <u>설계 와 **추가적인 요구사항에 대비하도록 애초에 상호 독립적인 개발이 가능하도록 코드를 짜는것이 중요**하다는걸 느낀다.</u>



**추가적인 요구사항을 해결하고자 추가한 기능이 기존의 코드를 망가뜨리는 경우가 많다...**



### MappingJacksonValue 적용이 기존 코드를 망가뜨렸다.



<u>request HTTP header의 세션 id에 따라 표시되는 데이터를 제한하고싶어서</u> MappingJacksonValue 를 이용해 응답 json 데이터를 필터를 써서 제한했다.



~~~java
//세션 검사..중략

MappingJacksonValue partPostData = new MappingJacksonValue(foundPost);
allPostData.setFilters(PARTPostInfo()); 

return partPostData
~~~



저기서 ALLPostInfo() 는 필터를 생성하는 코드를 리펙토링해서 메서드로 분리한것이다. 

> Post 객체의 일부 내용을 제한한하는 필터



문제는 이것을 적용하기위해 @JsonFilter("PostInfo") 가 추가되었는데 

~~~java
@JsonFilter("PostInfo")
public class Post {
    private Long id; 

    private String title;
    private String body
        
    ...

}
~~~



### 이게 기존에 있던 posts()에 에러를 발생시켰다.

~~~java
@GetMapping
public List<Post> posts() {
    return  postService.getPostList();//문제발생!
}
~~~



~~~
Cannot resolve PropertyFilter with id 'PostInfo'; no FilterProvider configured (through reference chain: java.util.ArrayList[0])
~~~

원래 Post class에 @JsonFilter("PostInfo") 가 추가되어 Post를 json으로 직렬화 할때 필터를 확인하고 적용해야하는데

기존 코드는 setFilters() 가 없어서 에러가 발생하는 것이다.



~~~java
@GetMapping
public MappingJacksonValue posts() {

    MappingJacksonValue postList = new MappingJacksonValue(postService.getPostList());
    postList.setFilters(PARTPostInfo());
    
    return postList;
}
~~~

이렇게 적용해서 간단히 해결했다.



## 느낀점

하지만 처음부터 완벽하게 설계를 했다면 더 좋았을것이라는 아쉬움이 남는다.

또한 이번에야 간단한 수준이었지만 복잡한 규모로 엮여있었다면 골치아팟을 것이다.

사실 어떤 요구사항이 변화할지 모르기때문에 미리미리 독립적으로 개발가능하도록 잘 코드를 짜야겠단 생각이 든다.





# restTemplate 한글 깨짐 이슈(feat. httpMessageConverter)

---

### 개요

RestTemplate를 사용해서 파이썬으로 만든 외부 머신러닝  API 서버로부터 Json 데이터를 받아왔다.

이때, 받아온 json을 자바 객체로 **역직렬화** 하는 과정에서 **한글이 깨지는 현상**이 발생했다.

이 문제를 해결한 방법에 대해 기록하고자 한다.



### RestTemplate 동작 원리에 답이있다.

https://onlyforus-blog.tistory.com/125?category=984678

이전에 정리했듯이  RestTemplate 는  **HttpMessageConverter** 를 이용해서 응답메세지를 java object(Class responseType) 로 변환한다.



RestTemplate 객체에 들어가보면 다음과 같이 setMessageConverters , getMessageConverters라는 메서드가 존재한다.

파라미터를 보면 HttpMessageConverter 리스트를 가지고 적용할 컨버터를 setting 할수있다는걸 알수있다.

~~~java
public void setMessageConverters(List<HttpMessageConverter<?>> messageConverters) {
		validateConverters(messageConverters);
		// Take getMessageConverters() List as-is when passed in here
		if (this.messageConverters != messageConverters) {
			this.messageConverters.clear();
			this.messageConverters.addAll(messageConverters);
		}
	}
~~~



https://onlyforus-blog.tistory.com/158

이전에 정리했듯이 스프링은 기본적으로 몇개의 HttpMessageConverter 를 제공한다.

> MappingJackson2HttpMessageConverter , StringHttpMessageConverter 등





확인해본 결과, restTemplate이 기본적으로 갖고 있는 messageConverter는 6가지가 있는데, 기존에 갖고 있던 StringHttpMessageConverter의 default Charset이 ISO-8859-1로 되어있었다.



### 한글이 깨지지 않게 하려면 초기 설정에서 StringHttpMessageConverter의 Charset을 UTF-8로 바꿔주면 될것이다.



~~~java
 @PostConstruct
    private void RestTemplateConverterSetting() {
        restTemplate.getMessageConverters().add(0,new StringHttpMessageConverter(Charset.forName("UTF-8")));

    }
~~~

나는  @PostConstruct를 사용해서 초기화 단계에서 설정하도록 했다.

HttpMessageConverter 리스트 맨 앞에 Charset이 UTF-8인 StringHttpMessageConverter를 추가했다.



~~~java
@PostConstruct
    private void RestTemplateConverterSetting() {

        MappingJackson2HttpMessageConverter mappingJackson2HttpMessageConverter = new MappingJackson2HttpMessageConverter();

        HttpMessageConverter stringHttpMessageConverter = new StringHttpMessageConverter(Charset.forName("UTF-8"));

        List<HttpMessageConverter<?>> httpMessageConverterList = new ArrayList<>();
        httpMessageConverterList.add(mappingJackson2HttpMessageConverter);
        httpMessageConverterList.add(stringHttpMessageConverter);

        restTemplate.setMessageConverters(httpMessageConverterList);
~~~

덧 붙이자면 이런식으로 컨버터들을 리스트로 생성해서 setMessageConverters 메서드를 사용해 사용할 컨버터를 설정해버려도 된다.







# HTTP 헤더

----

## 개요

웹 개발을 하다보면 항상 HTTP 헤더를 마주하게된다.

항상 많은 값들이 오고 가는것을 볼수있는데 각 역할이 무엇인지 어떻게 사용할수있는지에 대해서 정확히 정리한적이 없는것 같아서 이번 기회에 정리해보려한다.

---

## HTTP 헤더?

+ HTTP Header는 클라이언트와 서버가 요청 또는 응답으로 부가적인 정보를 전송하는 것

클라이언트가 서버로 요청을 할 때 혹은 서버가 클라이언트에 응답할 때 부가적인 정보를 담는 곳이 **헤더**라는 곳이다. 자바스크립트 객체와 비슷하게 키와 값이 쌍을 이루는 값으로 이루어져 있다. 예를 들어 키에는 `Content-Type` 라는 키와 값에는 `application/json` 등이 온다. 이 둘을 콜론으로 구분한다. 최종적으로는 `Content-Type: application/json`과 같은 꼴이 된다.

---

## 헤더의 종류

- General Header(공통 헤더)
- Request Header(요청 헤더)
- Response Header(응답 헤더)
- Entity Header(엔티티 헤더)

---

## General Header

HTTP 공통 헤더라고도 불린다. HTTP 통신을 하는 서버와 클라이언트측에서 모두 사용할 수 있는 헤더를 말한다. 이 공통 헤더는 일반적인 목적으로 사용되며 가장 기본적인 정보 등을 담는 헤더들이 있다.

### Date

HTTP 메세지를 생성한 일시를 뜻한다. (참고: [RFC1123](https://tools.ietf.org/html/rfc1123))

키는 **Date**로 사용되며 자바스크립트의 **Date** 객체를 `toGMTString` 메소드로 반환되는 문자열 방식을 쓴다. 예를 들어 `Date: Wed, 20 May 2020 02:44:49 GMT` 꼴로 쓴다.

### Connection

이 헤더는 HTTP 통신이 완료된 후에 네트워크 접속을 유지할지 말지를 결정하는 헤더다. 값으로는 `close`와 `keep-alive` 두 개가 있으며 `close`의 경우 통신이 완료된 후에 바로 연결을 끊겠다는 의미로, HTTP/1.0에서는 이 값이 기본 값이였다. 반대로, `keep-alive`의 경우에는 연결을 열린 상태로 유지하는 것을 나타낸다. HTTP/1.1에서 기본 값이다.

이 부분의 경우 이해하려면 시간이 조금 필요한 것 같아서 [참고 자료](https://developer.mozilla.org/ko/docs/Web/HTTP/Connection_management_in_HTTP_1.x)를 읽어 보아야 할 것 같다.

### Cache-control

서버와 클라이언트 요청 응답간의 캐싱 매커니즘을 위해 정의하는 헤더, 키:값으로 이루어진 헤더에서 '값'을 '디렉티브'라는 명칭으로 쓰인다.

이 디렉티브에는 매우 다양한 값이 올 수 있으며 주로 쓰이는 것 몇 가지만 정리한다.

- `max-age=[seconds]` 리소스가 최신 상태라고 판다할 최대 시간을 지정하는 디렉티브, 요청 시간과 관련이 있다.
- `no-store` 어떠한 요청과 응답에 대한 정보를 캐시하지 않는다.
- `no-transform` 응답에 대해 변형이나 변환이 일어나면 안된다. 컨텐츠의 헤더는 프록시에 의해 수정되면 안된다고 명시하고 이를 허용하지 않는다.
- `no-cache` 캐시된 복사본을 보여주기 전에, 재검증을 위한 요청을 서버로 보내도록 강제한다. (이 부분은 조금 더 찾아봐야 할 듯)
- `public` 응답은 어떠한 캐시에 의해서든 캐시될 수 있다.
- `private` 응답은 공유 캐시에 의해 저장되지 않아야 한다.

---

## Entity Header

주로 컨텐츠의 정보를 담기 위한 헤더이다. Content- 로 시작하는 헤더 키들이 있다.

- [Content-type](https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Content-Type) : 리소스의 media type 명시 ex) application/json, text/html
- [Content-Length](https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Content-Length) : 바이트 단위를 가지는 개체 본문의 크기
- [Content-language](https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Content-Language) : 본문을 이해하는데 가장 적절한 언어
- [Content-location](https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Content-Location) : 반환된 데이터 개체의 실제 위치 ex) /index.html
- [Content-disposition](https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Content-Disposition) : 응답 메세지를 브라우저가 어떻게 처리할지. 주로 다운로드에 사용
- [Content-Security-Policy](https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Content-Security-Policy) : 다른 외부 파일을 불러오는 경우 차단할 리소스와 불러올 리소스 명시
  - ex) default-src https -> https로만 파일을 가져옴
  - ex) default-src 'self' -> 자기 도메인에서만 가져옴
  - ex) default-src 'none' -> 외부파일은 가져올 수 없음
- [Content-Encoding](https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Content-Encoding) : 본문의 리소스 압축 방식. 주로 Content-Type과 같이 사용되며 참조되는 미디어 타입을 얻도록 디코드하는 방법을 클라이언트가 알게 해줍니다.
- [Location](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Location) : 301, 302 상태코드일 때만 볼 수 있는 헤더로 서버의 응답이 다른 곳에 있다고 알려주면서 해당 위치(URI)를 지정
- [Last-Modified](https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Last-Modified) : 리소스의 마지막 수정 날짜
- [Allow](https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Allow) : 지원되는 HTTP 요청 메소드 ex) GET, HEAD, POST
- [Expires](https://developer.mozilla.org/ko/docs/Web/HTTP/Headers) : 자원의 만료 일자
- [ETag](https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/ETag) : 리소스의 버전을 식별하는 고유한 문자열 검사기(주로 캐시 확인용으로 사용)

---

## Request Header

요청에 실리는 헤더들이다. 주로 클라이언트의 자체 정보를 담는 것들이 있다.

### Host

요청을 하는 주체에 대한 정보를 담는 헤더, HTTP/1.1 이후 이 헤더는 필수 항목이 되었다. `Host: developers.facebook.com`과 같이 쓰인다.

### User-Agent

클라이언트의 정보를 담는다. 여기에는 브라우저 엔진, 버전, 운영체제 등이 담길 수 있다. `User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko/20100101 Firefox/50.0` 꼴로 쓰인다.

### Accept

클라이언트가 어떤 컨텐츠 타입을 이해할 수 있는지에 대한 정보를 담는 헤더, MIME 타입으로 작성할 수 있으며 서버는 이 헤더를 참고해서 적절하게 응답할 수 있다. (Accept 헤더로 클라이언트가 이해할 수 있는 컨텐츠 타입을 나열하고, 서버는 그 중 하나를 선택해 Content-Type 헤더에 컨텐츠 타입을 내보낸다.)

`[MIME_Type]/[MIME_Subtype]`, `[MIME_TYPE]/*`, `*/*`, `;q=` 등으로 지정하는데, `text/html` 혹은 `application/json`과 같은 Type/Subtype을 지정해서 요청할 수도 있고 `text/*`과 같이 text라는 MIME Type을 가진 모든 컨텐츠를 요청할 수 있다. 그 뒤에 `;q=0.8`과 같이 부가 정보를 붙일 수 있는데, 이 부분은 이해하기가 어려워 MDN을 참고했다.

> 사용되는 모든 값들은 weight라고 부르는 상대적인 품질 값을 사용하여 표현되는 선호 순서로 대체됩니다. (q-인자 가중치에 대한 설명)





`Accept: text/html, application/xhtml+xml, application/xml;q=0.9, */*;q=0.8`과 같은 꼴로 헤더에 작성할 수 있다.

### Accept-Language

만약 다국어를 지원해야 하는 서비스를 운영하고 있을 경우 도메인을 다르게 해 각국의 언어로 작성된 페이지를 보여줄 수 있는데, 이런 방법을 사용하지 않는다면 클라이언트가 서버에게 직접 이해할 수 있는 언어를 헤더에 실어서 보낼 수 있다.

`Accept-Language: ko-KR, ko;q=0.5`과 같이 쓰인다.

### Accept-Encoding

요청해서 응답 받을 데이터의 압축 방식을 지정하는 헤더다. 크롬에서는 기본값으로 gzip으로 요청하는 것 같고, 그 외에 compress, deflate, br, identity 등을 사용할 수 있다.

### Authorization

주로 인증 토큰을 보낼 때 쓰는 헤더다. 다양한 언어에서 구현된 JWT 라이브러리로 만들어진 토큰을 이 헤더에 실어서 서버에 보낼 수 있다. 주로 `Authorization: Type Token` 꼴로 쓰인다.

일반적으로는 Type에 Bearer를 쓰고, Token에 Access Token을 담아서 서버에 보낸다. 서버는 이러한 토큰을 받아 검증하고 검증된 토큰이면 자원을 내보내고 그렇지 않다면 적절한 응답을 할 수 있다.

### Referer

이 헤더는 현재 요청된 페이지에서 이전에 방문한, 그러니까 내가 지금 보고있는 페이지를 어디로부터 들어오게 되었는지를 표시하는 헤더다. 다양한 애널리틱스 서비스에서는 이러한 헤더를 통해 사이트가 어디로부터 유입되었는지 정보를 얻어낸다.

> 사실 이 단어는 Referrer가 맞는 단어인데, 철자를 빠뜨렸다고 한다. 옳은 단어는 Referrer





이 헤더는 사생활과 관련된 브라우징 히스토리에 관한 정보를 노출할 가능성이 있다고 한다. 그리고 두 가지의 경우 서버로 전송되지 않는다.

1. 참조된 리소스가 로컬 파일인 경우와 데이터의 URI인 경우 (자바스크립트 파일 요청이나 CSS 파일 요청 등)
2. HTTP 요청이 사용되고 참조하는 페이지가 HTTPS를 사용할 경우

`Referer: https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Content-Range` 과 같이 쓰인다.

---

## Response Header

서버 자체의 정보를 담는 헤더, 컨텐츠에 대한 정보를 담을 수도 있다.

### Server

기본적인 서버의 정보를 담는 헤더다. 너무 많은 서버의 정보를 담게 되면 공격을 받을 수 있으므로 세부적으로 작성하는 건 피해야한다. 요청을 처리하는 서버측이 어떠한 소프트웨어를 사용하고 있는지 혹은 하위 제품에 대한 내용을 담는다.

`server: Netlify`과 같이 쓰인다.

### Access-Control-Allow-Origin

해당 Origin(주소)으로부터 오는 요청을 허용한다는 정보를 알려주는 헤더, `access-control-allow-origin: *`과 같이 쓰이는데, 와일드 카드 *가 오게되면 모든 Origin을 허용한다는 의미다.

그렇지 않고 Origin을 적게 되면 그 Origin으로 오는 요청만 허용한다는 의미다. 만약 허용되는 Origin이 아닌 다른 곳에서 요청이 오게 된다면 브라우저에서 CORS 오류를 뿜는다.



이 값은 하나의 Origin만 명시할 수 있으며 다양한 서버 사이드 언어에서 다양한 Origin을 허용할 수 있는 구현 방법이 있으니 참고하면 될 것 같다.

### Expires

리소스가 지정된 일시까지 유효하다고 나타내는 헤더. 캐시와 관련이 있으며 리소스에 대한 캐시가 언제 만료되는지를 알려주는 헤더다.

**Date**객체의 `toGMTString` 메소드로 반환되는 문자열을 값으로 사용하면 된다.

### ETag

HTTP 컨텐츠가 바뀌었는지에 대한 검증을 할 수 있는 태그다. 응답 본문이 변하지 않는다면 항상 똑같은 값을 내뱉고 변한다면 다른 값을 내뱉기 때문에 이로 인해 컨텐츠가 바뀌었는지 검증이 가능하며 만약 바뀌게 된다면 캐시를 지우고 새로 내려받게 된다.





## Reference

https://velog.io/@cham/HTTP-Header%EC%97%90%EB%8A%94-%EC%96%B4%EB%96%A4-%EC%A0%95%EB%B3%B4%EB%93%A4%EC%9D%B4-%EB%8B%B4%EA%B2%A8%EC%9E%88%EC%9D%84%EA%B9%8C







# [배포] Containerization vs Virtualization(feat. 도커)

----

### 도커란

기존에 OS 내부에 새로이 OS를 깔아서 독립시키는 가상컴퓨팅과 달리, 기존에 OS 내부에 프로세스를 독립시켜서 실행할수있도록 해주는 기술이다.

> 가상컴퓨팅은 리얼머신의 자원을 하드하게 분할받기 때문에 낭비가 심하다.
>
> >  ex) 생성과 동시에 리얼머신의 자원 20%를 정확히 가져가 사용한다.
>
> 예를들어 부엌이 이미 있는 집안에 부엌이 있는 작은 집을 또 만드는 것이다.
>
> 부엌이라는 자원이 중복되고 만들때 에초에 작은 집의 사이즈가 정해진다.



도커는 자원을 공유해서 사용하고 필요한 만큼만 가져다가 쓴다.

가상머신처럼 동작하지만 리얼머신에서 동작하는 것이라고 생각하면 된다.





### 배포

가상 머신에 경우 하드하게 생성되기 때문에 서버 컴퓨터로 옮기더라도  거기서 다시 생성해야한다. 

도커는 개발 환경을 이미지화 해서 어디로 옮겨지더라도 알아서 거기에 맞춰서 자동 생성된다.





각 컨테이너는 하나의 컴퓨터의 역할을 한다고 생각하면된다.

각 컨테이너에 필요한 환경(앱,라이브러리 등등)을 넣고 이미지화 시킨다.

이를 배포할 환경에 옮겨서 풀때 작업할 스크립츠를 짠다.

어떤환경에서도 도커를 이용하면 동작하게 할수있다.























## Reference

---

youtube.com/watch?v=hWPv9LMlme8







































