# Spring AOP

---

애플리케이션 로직은 크게 핵심 기능과 부가 기능으로 나눌 수 있다.

부가 기능은 이름 그대로 핵심 기능을 보조하기 위해 존재한다.

> 클래스가 100개면 100개 모두에 동일한 코드를 추가해야 한다.



부가 기능을 별도의 유틸리티 클래스로 만든다고 해도, 해당 유틸리티 클래스를 호출하는 코드가 결국
필요하다.

> 템플릿 메서드 클래스,전략 클래스 등으로 분리해도 결국 이 클래스를 호출하는 코드는 필요하다.



그리고 부가 기능이 구조적으로 단순 호출이 아니라 try~catch~finally 같은 구조가필요하다면 더욱 복잡해진다.



**부가 기능 적용 문제를 정리하면 다음과 같다.**

> 부가 기능을 적용할 때 아주 많은 반복이 필요하다.
> 부가 기능이 여러 곳에 퍼져서 중복 코드를 만들어낸다.
> 부가 기능을 변경할 때 중복 때문에 많은 수정이 필요하다.
> 부가 기능의 적용 대상을 변경할 때 많은 수정이 필요하다



### 누군가는 이러한 부가 기능 도입의 문제점들을 해결하기 위해 오랜기간 고민해왔다

그 결과 부가 기능을 **핵심 기능에서 분리**하고 **한 곳에서 관리**하도록 했다

그리고 해당 `부가 기능을 어디에 적용할지 선택하는 기능도 만들었다.` 이렇게 부가 기능과 부가 기능을 어디에 적용할지 선택하는 기능을 합해서 하나의 모듈로 만들었는데 이것이 바로 **애스펙트(aspect)**이다. 

> 이전에 알아본 `@Aspect` 가 바로 그것이다. 



**그리고 스프링이 제공하는 어드바이저도 어드바이스(부가 기능)과 포인트컷(적용 대상)을 가지고 있어서 개념상 하나의 애스펙트이다.**



애스펙트(관점)를 사용한 프로그래밍 방식을 관점 지향 프로그래밍 AOP(Aspect-Oriented  Programming)이라 한다.



### 참고로 AOP는 OOP를 대체하기 위한 것이 아니라 횡단 관심사를 깔끔하게 처리하기 어려운 OOP의 부족한 부분을 보조하는 목적으로 개발되었다.



## AspectJ 프레임워크

AOP를 대표적으로 구현한 AspectJ 프레임워크(https://www.eclipse.org/aspectj/)가 있다. 

> 물론 스프링도 AOP를 지원하지만 대부분 AspectJ의 문법을 차용하고, AspectJ가 제공하는 기능의 일부만 제공한다.



**AOP 적용 방식**

> 부가기능을 핵심 기능에 적용하는 방식 3가지 

컴파일 시점

> 컴파일 할때 실제로 부가 코드를 실제 코드에 붙여버린다.
>
> 따로 관리되고있지만 컴파일때 합쳐지면서 부가기능이 추가되는 구조
>
> **특별한 컴파일러가 필요하는 등 여러가지로 복잡하다**



클래스 로딩 시점

> .class 파일을 JVM 내부의 클래스 로더에 보관한다. 이때
> 중간에서 .class 파일을 조작한 다음 JVM에 올릴 수 있다. 
>
> JVM에 올릴때 Aspect를 적용해서 부가 기능이 더해진체 클래스를 올리는 것
>
> **클래스 로더 조작기를 지정해야 하는데, 이 부분이 번거롭고 운영하기 어렵다.**



**[채택!]** 런타임 시점(**프록시**) <- 이제것 알아본 방법

> 런타임 시점은 컴파일도 다 끝나고, 클래스 로더에 클래스도 다 올라가서 이미 자바가 실행되고 난 다음을 말한다. 
>
> 스프링과 같은 컨테이너의 도움을 받고 프록시와 DI, 빈 포스트 프로세서 같은 개념들을 총 동원해야 한다
>
> 
>
> 특별한 컴파일러나, 자바를 실행할 때 복잡한 옵션과 클래스 로더 조작기를 설정하지 않아도 된다. 
>
> **스프링만 있으면 얼마든지 AOP를 적용할 수있다.**
>
> ![image-20220208152240825](C:\Users\afrad\AppData\Roaming\Typora\typora-user-images\image-20220208152240825.png)



**총정리**

**컴파일 시점:** 실제 대상 코드에 애스팩트를 통한 부가 기능 호출 코드가 포함된다. AspectJ를 직접
사용해야 한다.

**클래스 로딩 시점:** 실제 대상 코드에 애스팩트를 통한 부가 기능 호출 코드가 포함된다. AspectJ를 직접
사용해야 한다.

**런타임 시점:** 실제 대상 코드는 그대로 유지된다. 대신에 프록시를 통해 부가 기능이 적용된다. 따라서 항상
프록시를 통해야 부가 기능을 사용할 수 있다. 스프링 AOP는 이 방식을 사용한다.



### AOP는 지금까지 학습한 메서드 실행 위치 뿐만 아니라 다음과 같은 다양한 위치에 적용할 수 있다.

> 프록시를 사용했기 때문에 메서드에만 적용된것
>
> 프록시 때문에 AOP 기능에 일부 제약이 있다는 설명



**적용 가능 지점(조인 포인트)**: 생성자, 필드 값 접근, static 메서드 접근, 메서드 실행

> 이렇게 AOP를 적용할 수 있는 지점을 조인 포인트(Join point)라 한다.



### 방식간의 차이

AspectJ를 사용해서 **컴파일 시점과 클래스 로딩 시점에 적용하는 AOP는** 바이트코드를 실제 조작하기 때문에 해당 기능을 **모든 지점에 다 적용**할 수 있다.

> 생성자,필드값,접근 메서드 등



**프록시 방식을 사용하는 스프링 AOP는** 메서드 실행 지점에**만** AOP를 적용할 수 있다.

> 프록시 방식을 사용하는 스프링 AOP는 스프링 컨테이너가 관리할 수 있는 스프링 빈에만 AOP를 적용할 수 있다.





### 그럼 제한이 있는 스프링 AOP를 사용할게 아니라 어디든 적용가능한 AspectJ 프레임웤을 사용해서 AOP를 구현하면 안될까?

AspectJ를 사용하려면 공부할 내용도 많고, 자바 관련 설정(특별한 컴파일러, AspectJ 전용 문법, 자바 실행 옵션)도 복잡하다. 



반면에 스프링 AOP는 프록시를 사용하기 때문에 메서드 실행시점에만 적용가능하지만 별도의 추가 자바 설정 없이 스프링만 있으면 편리하게 AOP 를 사용할 수 있다. 

실무에서는 스프링이 제공하는 AOP 기능만 사용해도 대부문의 문제를 해결할 수 있다. 



**그냥 편리하게 알아서 프록시 생성해주기때문에 @Aspect만 정의를해서 빈에 등록하면 AOP를 적용할수있다.**

> 이때까지 사용했던 방법







## AOP 용어 정리

정리하기..

**핵심**

스프링 AOP는 프록시 방식을 사용하므로 조인 포인트는 항상 메소드 실행 지점으로 제한된다.



프록시를 사용하는 스프링 AOP는 메서드 실행 지점만 포인트컷으로 선별 가능

주로 AspectJ 표현식을 사용해서 지정



어드바이스 + 포인트컷을 모듈화 한 것



스프링 AOP에서만 사용되는 특별한 용어





### [매우중요]스프링 AOP를 사용하면 편리하고 강력하게 AOP를 사용할수있다.

AOP라는건 스프링만의 고유한 개념은 아니다.

어떤 언어의 프로젝트에서든 별도로 존재하는 AspectJ프레임워크로 AOP를 구현할수있다.

하지만 AspectJ를 착안하여 프록시를 이용한 스프링 만의 AOP는 개발자 친화적으로 AOP를 적용할수있도록 해준다.







![image-20220208105331415](C:\Users\afrad\AppData\Roaming\Typora\typora-user-images\image-20220208105331415.png)

이걸 횡단 관심사 라고 한다.



횡단 관심사(cross-cutting concerns)가 된다. 쉽게 이야기해서 하나의 부가 기능이 여러 곳에 동일하게 사용된다는 뜻이다.





