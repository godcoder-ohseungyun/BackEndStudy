

# FactoryMethod , AbstarctFactoryMethod

---

**SimpleFactory** 기법에서 파생된 2 패턴,  **팩토리 매서드 패턴** & **추상팩토리메서드 패턴**

+ [[디자인 패턴\] Factory Method Pattern 팩토리 메소드 패턴 (tistory.com)](https://flower0.tistory.com/415)\
+ [[디자인패턴\] 팩토리 메서드 패턴 ( Factory Method Pattern ) :: victolee (tistory.com)](https://victorydntmd.tistory.com/299?category=719467)



## **SimpleFactory** 기법

---

어떤 상황에서 조건에 따라 **객체를 다르게 생성해야 할 때**가 있습니다.

예를 들면, 사용자의 입력값에 따라 하는 일이 달라질 경우, 분기를 통해 특정 객체를 생성해야 합니다.

객체마다 하는 일이 다르기 때문에 조건문에 따라 객체를 다르게 생성하는 것은 이상한 일이 아닙니다.



**SimpleFactory**는 이렇게 분기에 따른 **객체의 생성**( new 연산자로 객체를 생성하는 부분 )**을 직접하지 않고**,

**팩토리라는 클래스에 위임**하여 팩토리 클래스가 **객체를 생성하도록 하는 방식**을 말합니다.

팩토리는 말 그대로 **객체를 찍어내는 공장**을 의미합니다.



![image](https://user-images.githubusercontent.com/68331041/136687105-748d654e-5519-4643-8a64-b70d864795ac.png)

+ PizzaStore의 객체 생성 부분을 SimplePizzaFactory에게 위임

~~~java
public class SimplePizzaFactory { 
    //객체의 생성을 대신한다.
    public Pizza createPizza(String type) {
        Pizza pizza = null; 
        if( type.equals("cheese") ) 
            pizza = new CheesePizza(); 
        else if( type.equals("pepperoni") ) 
            pizza = new PepperoniPizza(); 
        else if( type.equals("calm") )
            pizza = new ClamPizza(); 
        return pizza; 
    } 
}

~~~



## 결론

기존의 PizzaStore는 CheesePizza PepperoniPizza ClamPizza등 앞으로 생성될 Pizza들과 계속해서 의존관계를 맺는다.

SimpleFactory의 적용으로 PizzaStore는 SimplePizzaFactory하고만 의존관계를 맺고 SimplePizzaFactory는 Pizza들과 의존관계를 맺는다.

+ SimplePizzaFactory는 SRP 단일 책임원칙을 만족한다.

+ PizzaStore의 강한 의존관계를 완화할수있다.

+ 피자를 생성하는 작업을 한 클래스에 **캡슐화**시켜 놓았기 때문에, 수정 사항이 있을 때 여기저기 다 들어가서 고칠 필요 없이 factory class **하나만 고치면 된다**.

  > PizzaStore과 같은 클래스가 여러개인경우 SimpleFactory적용이 없으면 수정사항이 발생하면 고치기 힘들다.





## 

## 팩토리 메소드 패턴 Factory Method Pattern

---

객체를 생성해내는 공장을 '인스턴스화'하여, 어떤 객체를 생성할지는 **서브클래스에게 맡기는 방법**이다.

**다양한 PizzaStore가 존재**하며, PizzaStore마다 **피자생성에 다양성**을 주고싶은경우



![image](https://user-images.githubusercontent.com/68331041/136687464-8ccc9f84-ad7c-45ab-8ed8-0ca042d6618e.png)

+ PizzaStore 내부에 객체 생성만을 처리하는 createPizza()메소드를 추상 메소드로 선언한다. **->인스턴스화**
+ 그리고 PizzaStore를 상속받은 NYPizzaStore과 ChicagoPizzaStore에서 createPizza()메소드를 구현하며, 직접 필요한 객체를 생성한다. **->서브클래스에서 어떤 객체를 생성할지 결정한다.**



## 결론

**Creator** 클래스(PizzaStore)가 **ConcreteProduct**(ConcretePizzaStore)와 **느슨하게 결합**되어 있다.

> **공통 리모컨**을 사용함으로 쉽게 갈아끼울수있다. **유연성+확장성**

**서브클래스가** 직접 객체 생성을 **자유롭게 정의**할수있다.







## 추상 팩토리 패턴 Abstract Factory Pattern

---

+ 추상 팩토리 패턴은 서로 **연관되거나 의존적인 객체들의 조합**(family)을 만드는 **인터페이스를 제공**하는 방법이다.

  



팩토리 메소드 패턴까지 설명하자면, PizzaStore가 있고 그걸 상속받는 서브 클래스 (NYPizzaStore, ChicagoPizzaStore)가 있다.

여기서 뉴욕가게와 시카고가게에서 Pizza(객체)를 만들 때 **사용되는 재료들은 중복**된다.

**세부 디테일이 다를 수 있지만** 두 가게 모두 도우, 소스, 토핑, 치즈가 필요하듯이 **큰 틀은 비슷하다**.

하지만 **가게마다 다른 재료 종류**를 사용할수도있다. **이러한 부분을 묶어서 팩토리화하여 인터페이스를 제공**하는것이 **추상팩토리패턴**이다. 



![image](https://user-images.githubusercontent.com/68331041/136687969-f8f72a38-755d-4f2c-94e7-44d959e923f0.png)

+ 인터페이스로 공통리모컨을 만들고 PizzaStore마다 사용할 Factory를 구현한다.

~~~java
public class NYPizzaStore extends PizzaStore { 
    
    protected Pizza createPizza(String item) { //Factory Method Pattern의 서브클래스's create method
        
        Pizza pizza = null; 
        
        PizzaIngredientFactory ingredientFactory = new NYPizzaIngredientFactory(); //재료팩토리 has - a
        
        if( item.equals("cheese") ) { 
            pizza = new CheesePizza(ingredientFactory); //재료팩토리 전달
            pizza.setName("New York Style Cheese Pizza"); 
        } 
        else if( item.equals("clam") ) {  //재료팩토리 전달
            pizza = new ClamPizza(ingredientFactory); 
            pizza.setName("New York Style Clam Pizza"); 
        } 
        else if( item.equals("pepperoni") ) {  //재료팩토리 전달
            pizza = new PepperoniPizza(ingredientFactory);
            pizza.setName("New York Style Pepperoni Pizza"); 
        } 

~~~

+ 서브 클래스에서 객체 생성할때 재료팩토리를 전달한다.

~~~java
public class CheesePizza extends Pizza { 
    PizzaIngredientFactory ingredientFactory;
    
    public CheesePizza(PizzaIngredientFactory ingredientFactory) { 
        this.ingredientFactory = ingredientFactory; //재료팩토리 DI
    }   
    public void prepare() { 
        System.out.println("Preparing " + name); 
        doug = ingredientFactory.createDough(); //팩토리DATA
        sauce = ingredientFactory.createSauce(); 
        cheese = ingredientFactory.createCheese(); 
    } }

~~~

+ 해당 객체가 생성될때 주입받은 팩토리를 이용하여 생성한다.





## 정리

구상 형식에 대한 의존을 피하고 추상화를 지향할 수 있다.

**[단점]**

제품군에 제품을 추가하려면 인터페이스를 바꿔야 한다. 

위의 피자 예시로 보면, NYPizzaStore에 불고기피자를 추가하려면 PizzaIngredientFactory를 수정해야 하고, 그것을 상속받은 모든 서브 클래스(NYPizzaIngredientFactory)의 인터페이스도 수정이 필요하다. 





# 종합정리

결국 **모든 팩토리의 공통점**은 객체 **생성을 캡슐화**해서 애플리케이션의 **결합을 느슨하게 만들고, 특정 구현에 덜 의존이게 만든다는 것**이다.











