





# 전송 오류 복구

---

### 프로토콜 별 정보 전송 단위 명칭

IP ,UDP 프로토콜

> **데이터그램**

 TCP 프로토콜

> **세그먼트**





## 대부분의 오류복구는 TCP에서 제공하며 이루어진다.

> **IP나 UDP**는 간단한 전송 프로토콜로 **오류복구 기능을 제공하지 않는다**.



### 세그먼트

![image](https://user-images.githubusercontent.com/68331041/135827949-56afce7c-41d8-40bd-a6d5-a902fec3a50e.png)

#### **세그먼트 오류**

세그먼트 훼손 : 훼손된 세그먼트 도착(Checksum으로 확인)

세그먼트 손실 : 세그먼트 미도착(중간 통신장치의 버퍼 오버플로우)



#### **세그먼트 수신 확인**

> 1.세그먼트 정상 수신 -> **수신확인(ACK) 세그먼트 회신**
>
> > **ACK(acknowledgement)**
> > 수신자가 데이터 세그먼트의 정상수신을 확인하기 위해 송신자에게 보내는 특수한 세그먼트
>
> 
>
> 2.훼손 세그먼트 수신 -> 폐기 -> 미수신
>
> 
>
> 3.세그먼트 미수신 -> 인지 불가
>
> > **세그먼트 미수신 확인**
> >
> > 세그먼트 전송 후 **타이머**(timer) 개시
> >
> > 타이머 종료시까지 ACK 미도착



#### **RTT**: 전송후 회신 ACK 도착까지 걸리는 시간





### 오류 세그먼트 복구 절차

1) 세그먼트 전송, 타이머 시작
2) 세그먼트 타이머 종료할 때까지 ACK 미도착
3) **세그먼트를 재전송하고 타이머 재시작**



# TCP, 세그먼트 오류 복구 기법

---



## [1. Stop-and-Wait ARQ 기법]

+ Automatic Repeat Request

+  ### <u>ACK 회신 될때까지 전송을 멈추고 대기</u>



**송신자**
1) 세그먼트 **송신 후** **복제본을 버퍼에 유지**
2) 재전송 타이머 시작
3) 타이머 종료 전 ACK **수신 시** 복제본 폐기, 타이머 종료
4) 타이머 종료 전 ACK **미수신 시** 세그먼트 재전송, 타이머 재시작

**수신자**
1) 정상 세그먼트 수신 시 ACK 회신

> **ACK 도 세그먼트의 일종**으로 송신 오류가 날수있다.
>
> **정상 수신시에도 수신자 ACK 송신오류로 미수신 처리 될수있다.**
>
> **이때 재전송**함

<img src="https://user-images.githubusercontent.com/68331041/135829826-83400bc1-46f3-41b5-8bd2-f8fd4eef05c3.png" alt="image" style="zoom:50%;" />



### ACK 송신 오류로 정상 수신된 세그먼트가 미수신 처리되었을때 중복 수신이 되는데 Stop-and-Wait ARQ 기법은 이를 구분할 방법이 없다.

> Stop-and-Wait ARQ with SN 로 **해결가능!**





---

## Stop-and-Wait ARQ with SN

+ #### 송신 세그먼트 해드에 **SN**을 넣어 넘버링을 한다

  >  **0 또는 1** 값을 가져도 충분히 중복수신 구분가능

+ #### **중복수신 구분가능**



<img src="https://user-images.githubusercontent.com/68331041/135831035-c399c5e9-0dd7-42aa-b07e-6d29e4f2cecf.png" alt="image" style="zoom:50%;" />

+ 정상인경우 0 1 0 1 0 1 순으로 SN에 넘버를 달고 segment 가 들어올것임

> 1. 0 번 세그먼트 정상수신
> 2. **1 번을 붙여셔 ACK 송신**
> 3. 이때 **전송오류 발생**
> 4. 송신자는 **미수신으로 인식**하고 **0번 세그먼트 재 송신**
> 5. 수신자는 0 번 세그먼트가 또 들어옴으로써 **중복수신임을 눈치채고 구분가능** 
>



### SN에 0과 1 즉 1비트만 사용해도 충분히 중복수신 구분이 가능하다.



### 문제점 : 낮은 링크 사용 효율성

> **ACK가 도착할 때까지 전송 대기** -> 대기때문에 링크성능 만큼 전송을 할수없다.
>
> **대기 시간 동안 링크 미사용** -> 링크 사용률 저하



## Stop-and-Wait 는 실제 네트워킹에 사용하기엔 부적합하다.



---



## [2. Go-back-N ARQ기법]

+ #### 파이프 라이닝을 활용한 기법

+ #### <u>**오류 세그먼트**부터 **이후**의 **모든 세그먼트 재전송**</u>



### 파이프 라이닝

+ 다수의 데이터를 한번에 일정량을 전송하는 것
+ **ACK가 회신 되기전 RTT 동안 링크에 M개의 세그먼트를 전송**

> **RTT**:  ACK 도착까지 대기시간.

+ 링크 효율 제고(stop-and-wait 보다 M배 높은 효율)

<img src="https://user-images.githubusercontent.com/68331041/135836604-78dd4778-8faa-461b-8e33-3b5efd82504e.png" alt="image" style="zoom:50%;" />

+ Stop-and-Wait ARQ with SN 기법과 달리 **SN에 0,1만 사용하지 않는다.** 



### **[전체 과정]**

**send window 최대크기**는 2^3 -1  = **7** 이다. **문제에서는 M=4**로 설정 7을 넘어가면 문제발생 -> 아래에서 다룸

![image](https://user-images.githubusercontent.com/68331041/135841790-37ddaf94-1791-41ea-8a31-3018989c353e.png)

1) ACK가 회신 되는 **RTT 동안** 링크에 최대 M개의 **세그먼트를 전송**하고 **버퍼에 유지**

2) **ACK 수신하면** 해당 세그먼트(첫번째 세그먼트)을 버퍼에서 제거하고 송신가능 순서번호 **범위를 1씩 이동** (= 윈도우 슬라이딩)

> **송신 슬라이딩 윈도우 최대 크기**
>
> > **2^m -1**  (m = SN 비트크기)
> >
> > ex) SN 4비트 일때  = 15

3) 세그먼트 재전송 타이머가 종료될 때까지 **ACK가 수신되지 않으면** 해당 세그먼트부터 송신 윈도우 의 모든 세그먼트 재전송

> **송신 윈도우**
>
> > 파이프 라이닝에서 **한번에 전송 가능한 세그먼트 수** (=범위)
> >
> > > **S max(송신 슬라이딩 윈도우 최대크기) 이하**의 수를 갖는다.
>
> 송신 후 버퍼에 유지되어야 할 세그먼트의 범위



**세그먼트 넘버 0123 전송 0,1번 ACK 수신** 

**윈도우 슬라이딩 후 4 5 넘버를 달고 세그먼트 2개 더 송신가능**

**전송중인 세그먼트는 2 3 4 5**

**2번세그먼트 로스로 인한 타임아웃**

**2번이후 전송사항 전부 패기(discard)**

**2345 재전송**





### SN필드크기 m  bit 일때  왜  ''최대 '' 송신윈도우 크기는  '' 2^m - 1 '' 이어야한다.

> 그래야 정상과 비정상 세그먼트 넘버를 구분할수있다.

![image](https://user-images.githubusercontent.com/68331041/135845501-9e2e0705-43fd-47b0-952b-ccf84ff69a96.png)





### **장점**
Stop-and-wait 대비 고효율성
간단한 수신자 버퍼 관리(다음 세그먼트 수신용 버퍼)



### **단점**
오류 세그먼트 이후 도착한 정상 세그먼트 재전송
불필요한 재전송 회수 증가
링크 효율 저하



---



## [3. Selective_Repeat ARQ 기법]


+ #### <u>오류 세그먼트만 재전송</u>



+ #### **수신 윈도우**와 **송신 윈도우** 두개를 가진다.

>  **송 수신 윈도우 최대 크기(M)가  Go-back-N ARQ기법과 다르다**. 2^(m-1) 이다.  2^(3-1) = 4   최대 4이다. 문제에서는 M=4로 설정

![image](https://user-images.githubusercontent.com/68331041/137326392-7b45025e-6614-4fc0-849a-bfabae3d8523.png)

> 1. ACK가 회신 되는 RTT 동안  송신 윈도우 최대크기인 S max 이하의 세그먼
>    트를 전송
>
> 
>
> 2. **누적 ACK**(accumulative ACK) 수신하면 송신 윈도우를 누적 ACK 수만큼 이동**(=윈도우 슬라이딩)
>
> 
>
> 3. **비누적 ACK**(non-accumulative ACK) 수신하면 해당 세그먼트의 **''ACK 수신 사실**
>    **기록''**  (***노란색 표시**)
>
> 
>
> 4. 세그먼트 **재전송 타이머가 종료**될 때까지 ACK가 수신되지 않으면 해당 세그먼
>    트 **재전송**



## Go-back-N ARQ기법의 단점 해결

