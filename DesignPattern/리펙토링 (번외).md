# 리펙토링

---

### + 관찰되는 행위의 변화 없이 코드의 가독성과 수정 용이성을 향상 시키기 위해 소프트웨어 내부 구조를 변경하는 것

> **이유 1.** 소프트웨어 설계를 향상시키기 위해
>
> > 중복 코드 제거 -> 수정용이성 향상
>
> **이유 2.** 소프트웨어 이해도 향상 (가독성 향상)
>
> > 다음 사람을 위해, (다음 사람이 나일 수도, 아마 종종 나)
>
> **이유 3.** 버그 찾는데 도움
>
> > 리펙토링을 통해 가독성이 향상되고 코드에 대한 이해도가 높아지면 생각하지 못한 버그를 발견할 수 있음
>
> **이유 4.** 프로그래밍(개발)하는 속도 향상
>
> > 소프트웨어가 잘 설계되어 있을 수록 소프트웨어 개발 속도를 높일 수 있음

### + 리펙토링 문제점

> 많은 비즈니스 응용은 **데이터베이스 스키마와 단단하게 연결**되어 있어 리펙토링할 때 **어려운 경우**가 있음
>
> 견고한 테스트가 꼭 필요
>
> 소프트웨어 설계 자체의 변경
>
> Legacy code를 리펙토링하는 것은 쉽지 않음
>
> > **Legacy code:** 누군가 남겨두고 떠난 코드



#### **Refactoring의 첫 단계: 테스트 프로그램 만들기**

> 리펙토링은 **기능은 유지한 상태에서 코드를 개선**해야한다.
>
> 리펙토링 이후에도 **기존 테스트 코드에서 동일하게 동작**해야 한다.
>
> 만약, 테스트코드가 충분치 않을때는 리펙토링 이후 테스트 코드를 추가하면 된다.



### Extract Method

> 긴 메소드의 일부 코드를 새 메소드로 정의하는 것
>
> 메서드 네이밍을 이용한 재구성으로 **가독성 향상**
>
> 분산구조로 **재정의 용이**



### Move Method

> 한 메소드의 정의 위치(클래스)를 바꾸는 리펙토링
>
> 메소드의 올바른 위치로 재배치



### Split Loop

> 한 루프를 통해 계산할 수 있더라도 서로 다른 일이면 분리



### Parameterize Function 

> ~~~java
> void tenPercentRaise(){
> 	salary *= 1.1;
> }
> 
> void fivePercentRaise(){
> 	salary *= 1.05;
> }
> 
> //수치 상수만 차이가 있는 유사한 일을 수행하는 두 개의 함수가 있다면 매개변수를 추가하여 중복방지
> 
> void raise(double factor){
>  	salary *= (1+factor);
> }
> ~~~



### Remove Flag Argument

> **flag 인자를 사용하는 경우** **분리**해서 메서드 네이밍을 사용 가독성을 향상
>
> **flag 인자 제거**
>
> ![image](https://user-images.githubusercontent.com/68331041/137436029-12591fb3-a8db-4980-93ae-712514145834.png)



### 불필요한 임시 변수 제거

> 임시로 데이터를 저장하기 위해 존재하는 변수들을 제거
