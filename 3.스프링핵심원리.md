# 스프링의 핵심원리

---

[목표]

+ 객체지향설계
+ 아키텍쳐고려
+ 전체적인 동작원리이해

---

[스프링을 사용하는 이유](#스프링을-사용하는-이유)

[시작하기](#시작하기)

[스프링으로 전환](#스프링으로-전환하기)

## 스프링 프레임워크

• 핵심 기술: 스프링 DI 컨테이너, AOP, 이벤트, 기타
• 웹 기술: 스프링 MVC, 스프링 WebFlux
• 데이터 접근 기술: 트랜잭션, JDBC, ORM 지원, XML 지원
• 기술 통합: 캐시, 이메일, 원격접근, 스케줄링
• 테스트: 스프링 기반 테스트 지원
• 언어: 코틀린, 그루비
• 최근에는 **<u>스프링 부트</u>**를 통해서 **스프링 프레임워크**의 기술들을 편리하게 사용



## 스프링 부트 

• 스프링을 편리하게 사용할 수 있도록 지원, 최근에는 기본으로 사용
• 단독으로 실행할 수 있는 스프링 애플리케이션을 쉽게 생성
• **Tomcat** 같은 웹 서버를 내장해서 별도의 웹 서버를 설치하지 않아도 됨

> Tomcat:: 과거에 설치해서 사용했던 별도의 JAVA전용 웹 서버

• 손쉬운 빌드 구성을 위한 starter 종속성 제공 (**라이브러리 활용시 자동화로 보조하는 기능**)
• 스프링과 3rd parth(외부) 라이브러리 자동 구성 (**외부 라이브러리 버젼 호환성을 자동 관리**)
• 메트릭, 상태 확인, 외부 구성 같은 프로덕션 준비 기능 제공
• 관례에 의한 간결한 설정 (대부분 관례에 따라 공식적인 설정을 사용)



### 스프링을 사용하는 이유

스프링은 자바 언어 기반의 프레임워크
• 자바 언어의 가장 큰 특징 - 객체 지향 언어(추상화 캡슐화 상속 다형성)
• 스프링은 **객체 지향 언어가 가진 강력한 특징을 살려내는 프레임워크**
• 스프링은 좋은 **객체 지향 애플리케이션을 개발**할 수 있게 도와주는 프레임워크

객체 지향 프로그래밍은 프로그램을 **유연하고 변경이 용이하게 만들기 때문**에 대규모 소프
트웨어 개발에 많이 사용된다. 



# 시작하기(순수 자바코드로..)

---

에자일 소프트웨어 개발선언

> 계획을 따르기 보다 변화에 대응하기를

## 다형성을 이용한 객체지향 설계

인터페이스와 구현 객체를 통해 코드를 짜면 추상(인터페이스) 뿐만 아니라 구체(구현) 클래스에도 의존하고 있다. 또한 수정 발생시 중복된 모든 코드를 수작업으로 고쳐야한다.

~~~java
//in something impl
private final DiscountPolicy discountPolicy = new RateDiscountPolicy();
~~~

이 코드를 **DIP**(구현 클래스에 의존하지 말고, 인터페이스에 의존)를 위반하지 않게 수정하려면

~~~JAVA
//in something impl
private  DiscountPolicy discountPolicy
    
//생성자
    //..
~~~

이렇게 인터페이스에만 의존해야한다. 생성자를 만들어 구현체를 할당받도록하고 구현체 할당은

외부에서 일괄적으로 담당하게한다.

![AppConfig](C:\Users\afrad\OneDrive\문서\SpringFramwork\AppConfig.PNG)

**해결책:** 구현체를 직접 할당하지않고 구현체를 알아서 할당하도록하는 별도의 클래스(AppConfig)를 만들어서 관리하자

**AppConfig**를 만들어서 사용하여  **생성자 주입!!**

> "생성자 주입 == 의존관계 주입" 알아둬야할 표현

~~~java
//in something impl
private final MemberRepository memberRepository;
    
public MemberServiceImpl(MemberRepository memberRepository) { //생성자를 이용하여 객체 생성
    this.memberRepository = memberRepository;
}
//MemoryMemberRepository 라는 구현 객체에 의존하지 않고 추상화에만 의존
~~~

이전 처럼 직접 구현 객체를 넣어주는게 아니라 생성자를 만든후 AppConfig에서 구현객체를 일괄적으로 넣어준다.

~~~java
//in AppConfig
public class AppConfig {

    public MemberService memberService() {
        return new MemberServiceImpl(new MemoryMemberRepository()); //생성자에 구현객체를 넣어 반환 (생성자 주입)
    }
}
~~~

이렇게 하면 AppConfig에서 구현 객체들을 관리하여 해당 구현부에 넣어줄수있고 구현부는 인터페이스 에만 의존할수있다.

**something Impl 의 생성자를 통해서 어떤 구현 객체을 주입할지는 오직 외부( AppConfig )에서 결정**

**이제부터 실행에만 집중하면 된다**



하지만 현재 AppConfig를 보면 중복이 있고, 역할에 따른 구현이 잘 안보인다.

이러면 수정할때 중복을 일일히 고쳐줘야하고 코드리드가 쉽지않다. 

리펙터링을 통해 중복을 제거하고 역할이 잘 보이게 하자.

## 리펙터링

~~~java
//in AppConfig
public class AppConfig {

    public MemberService memberService() {
        //return new MemberServiceImpl(new MemoryMemberRepository()); 
        return new MemberServiceImpl(memberRepository()); //리펙토링
    }
    
   //ctrl+alt+m 리팩토링 단축키
    //반환타입은 interface로 하여야 한다. 다형성을 위하여
    //이제 구현객체가 변환되는 일이 발생할때 아래 return 부분의 new 객체만 바꿔주면 
    //모든 코드에 적용된다.
    private MemberRepository memberRepository() {
        return new MemoryMemberRepository();
    }
    
}
~~~

이제 구현을 변경해도, 애플리케이션의 구성 역할을 담당하는 **AppConfig만 변경**하면 된다. 클라이언트 코드인 OrderServiceImpl 를 포함해서 **사용 영역의 어떤 코드도 변경할 필요가 없다**.
구성 영역은 당연히 변경된다. 구성 역할을 담당하는 AppConfig를 전체 애플리케이션의 총 관리자라고 생각하자

**SOLID중 3가지 SRP, DIP, OCP 에 만족함을 확인해 보라**

> 한 클래스는 하나의 책임만 가져야 한다.
>
> 프로그래머는 “추상화에 의존해야지, 구체화에 의존하면 안된다.” =>  AppConfig가 의존성 주입
>
> 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다  =>  AppConfig가 의존성 주입



## IoC(제어의역전), DI(의존관계주입), 그리고 컨테이너

---

>  AppConfig 처럼 객체를 생성하고 관리하면서 의존관계를 연결해 주는 것을
> IoC 컨테이너 또는 DI 컨테이너라 한다. 
> 의존관계 주입에 초점을 맞추어 최근에는 **주로 DI 컨테이너**라 한다.
> 또는 **어샘블러, 오브젝트 팩토리 등으로 불리기도 한다.**

**제어의 역전 IoC(Inversion of Control)**

> 프로그램에 대한 **제어 흐름에 대한 권한은 모두 AppConfig가 가지고 있다**
>
> **내부 구현 로직들은 추상화에 의존**함으로 프로그램 **제어권한이 없다**
>
> 이렇듯 프로그램의 **제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것을 제어의 역전(IoC)**이라 한다.

**프레임워크 vs 라이브러리**

> 프레임워크가 내가 작성한 코드를 제어하고, **콜백식으로 내 코드를 받아가서 대신 실행**하면 그것은 프레임워크가 맞다. (JUnit)  
>
> > ***콜백**: 인수로써 넘겨지는 실행가능한 코드 받아졌다가. 나중에 필요할때 실행될수있다.
>
> 반면에 내가 작성한 코드가 직접 제어의 흐름을 담당한다면 그것은 프레임워크가 아니라 라이브러리다.

**동적의존관계vs정적의존관계**

> **동적의존관계:** 애플리케이션 실행 시점에 **실제 생성된 객체 인스턴스의 참조**가 **연결된 의존 관계**다.  ***의존관계 주입(DI)이 된 의존관계**
>
> **정적의존관계:** 인터페이스간의 의존관계, 클래스 다이아그램을 의미하며 실행하지 않고도 판단할수있다. ***의존관계 주입이 안된 의존관계**

**AppConfig를 이용하여 정적 의존관계(사용자 영역)를 변경하지 않고 동적의존관계(AppConfig)를 수정할수있었다. From 의존관계 주입**



# 스프링으로 전환하기

---

AppConfig를 이용해서 전체 프로그램 제어를 할수있게 되었다. 하지만 AppConfig 객체를 생성하여 직접 제어를 해야할까? 스프링컨테이너를 이용하여 관리를 위임할수있다.

**스프링 컨테이너 사용하기**

AppConfig에 설정을 구성한다는 뜻의 **@Configuration** 을 붙여준다.
각 메서드에 **@Bean** 을 붙여준다. 

이렇게 하면 스프링 컨테이너에 스프링 빈을 등록한다.

~~~java
 @Configuration
 class AppConfig(){

 	@Bean 
     //@Bean(name="이름") //사용자 지정 naming
     //default == method name
     //method
 	..
 }
~~~

이제 스프링 컨테이너가 빈을 관리해준다.

**컨테이너 빈 사용하기**

~~~java
//ApplicationContext 를 스프링 컨테이너라 한다. ApplicationContext 는 인터페이스이다.
ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class);
//AppConfig==구현객체 to 스프링 컨테이너
MemberService memberService = applicationContext.getBean("memberService", MemberService.class);
//사용할 Bean 객체
//(이름,반환타임.class)
~~~



**기존에는 개발자가 직접 자바코드로 모든 것을 했다면 이제부터는 스프링 컨테이너에 객체를 스프링 빈으로**
**등록하고, 스프링 컨테이너에서 스프링 빈을 찾아서 사용하도록 변경되었다.**

### 이 스프링 컨테이너를 활용하면 얻는 이점은 어마어마할것이다.



## 스프링 컨테이너란?

---

**ApplicationContext** 를 **스프링 컨테이너**라 한다. ApplicationContext 는 **인터페이스**이다.

> ApplicationContext는 BeanFactory(최상위 인터페이스)의 기능을 상속받는다.
> **ApplicationContext는 BeanFactory(빈 관리기능) + 편리한 부가 기능(다양한 인터페이스)을 상속받는다.**
>
> > **ApplicatonContext가 제공하는 부가기능**
> >
> > **메시지소스를 활용한 국제화 기능**
> > 예를 들어서 한국에서 들어오면 한국어로, 영어권에서 들어오면 영어로 출력
> > **환경변수**
> > 로컬, 개발, 운영등을 구분해서 처리
> > **애플리케이션 이벤트**
> > 이벤트를 발행하고 구독하는 모델을 편리하게 지원
> > **편리한 리소스 조회**
> > 파일, 클래스패스, 외부 등에서 리소스를 편리하게 조회
>
> BeanFactory를 직접 사용할 일은 거의 없다. **모든 부가기능이 포함된 ApplicationContext를 사용한다.**
> **BeanFactory나** **ApplicationContext를 스프링 컨테이너라 한다.**

스프링 컨테이너는 파라미터로 넘어온 설정 클래스 정보를 사용해서 **스프링 빈을 등록**한다.

**AppConfig** 를 사용했던 방식이 **애노테이션 기반의 자바 설정 클래스**로 스프링 컨테이너를 만든 것
이다.

이 클래스(AppConfig)는 일종의 **ApplicationContext 인터페이스의 구현체**이다.

**빈 조회**

>  스프링 컨테이너에 조회된 빈을 조회하는 방법은 Practice beanfind folder를 참조하자
>
> **빈 조회의 상속 관계**
>
> 부모 타입으로 조회하면, 자식 타입도 함께 조회한다.
> 그래서 모든 자바 객체의 최고 부모인 Object 타입으로 조회하면, 모든 스프링 빈을 조회한다.



## BeanDefinition

---

**스프링은 어떻게 이런 다양한 설정 형식을 지원하는 것일까?** 그 중심에는 **BeanDefinition 이라는 추상화**
가 있다.

**스프링 컨테이너는 자바 코드인지, XML인지 몰라도 된다**. 오직 BeanDefinition만 알면 된다

AnnotationConfigApplicationContext 는 AnnotatedBeanDefinitionReader 를 사용해서
AppConfig.**class 를 읽고 BeanDefinition 을 생성**한다.

BeanDefinition에 대해서는 너무 깊이있게 이해하기 보다는**, 스프링이 다양한 형태의 설정 정보를**
**BeanDefinition으로 추상화해서 사용하는 것** 정도만 이해하면 된다. 

가끔 스프링 코드나 스프링 관련 오픈 소스의 코드를 볼 때, BeanDefinition 이라는 것이 보일 때가 있다. 
이때 이러한 메커니즘을 떠올리면 된다.













