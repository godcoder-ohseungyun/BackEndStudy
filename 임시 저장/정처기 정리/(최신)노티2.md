# 1장 

---

### 요구사항 검토방법

**동료검토:** 작성자가 설명 , 동료가 결함 검토

**워크 스루:** 미리 배포하고 짧은 회의 

**인스펙션:** 작성자 제외, 다른 전문가가 검토





### 시스템 구성요소

프로세스,피드백,출력,제어, 입력



### DFD(데이터 흐름도) 

**구성요소:** Process , Data flow , Data Store , Terminal

**특징:** 명확한 시간 표현 불가 , 구조적 분석기법, 원 화살표로 표시





### 상향식 , 하향식 통합테스트

**하향식 통합 테스트** 상위에서 하위로 통합하면서 테스트

**상향식 통합 테스트** 하위에서 상위로 통합하면서 테스트





### 럼바우 객체지향 분석 기법 다이어그램

+ 객동기

**객체 모델링** <u>객체 다이어그램 이용</u>

**동적 모델링** <u>상태 다이어그램 이용</u>  흐름등 동적 행위 표현하는 모델링 기법임

**기능 모델링** 자료 흐름을 이용



### 객체지향 용어

캡슐화(Encapsulation)

상속성(Inheritance)

다형성(Polymorphism)



### 미들웨어 종류

WAS RPC ORB    

+ 웹 서버는 소프트웨어임



### DBMS 분석 고려사항

무결성 , 가용성 , 일관성 , 회복성 , 상호 호환성 , 보안  , 효율성, 성능 , <u>데이터베이스 확장</u>



### 결합도는 낮게 응집도는 높게





### UML 확장모델

<<>> 스테레오 타입

\+ 퍼블릭

\- 프라이빗

\# 프로텍트

\~ 동일 패키지 접근 허용

~~~
- - - -> 의존: A가 B를 필요로하는 경우가있다
-> 연관: A의 맴버로 B가 있다
- - - -|> 구현(실체화)
-|> 일반화(상속):  자손 A가 B를 상속받음 
~~~



### 연계시스템 구성: 시스템끼리 연계

**송신 시스템:** 송신담당

**수신 시스템 :** 수신 담당

**중계 서버:** 송수신 모니터링



### XP

+ 에자일 기법에 XP와 스크럼이 있다.

+ 5가지 가치: **용단커피존**(용단! 커피줘)

  > 용기 단순 커미뉴케이션 피드백 존중





### LOC

총 / 생산량 * 인원 = 소요 기간





### 요구사항 명세 기법

**정형** 코드로 설명 같은 느낌

> 수학기반
>
> Z , VDM , Petri Net 모형 기반
>
> CSP , CCS LOTOS 대수방법 기반
>
> 정확 간결 
>
> 이해도 요구 

**비정형** 말로설명 같은 느낌

> 자연어 기반 
>
> 상태 기능 객체 중심 명세
>
> 간편하고 다양함
>
> 자유도만큼 불친절할수있음





### 시퀀스(순차) 다이어그램*  이거 카카오에서 문서에 자주씀 Oauth 같은거 설명할때

+ 동적 다이어 그램
+ **구성요소:** **액 객 생 메 실** (액(객)체 생매실)

> 액터(actor), 객체, 생명선, 메세지, 실행(active)



### CASE원천기술

소프트웨어 공학에서의 여러 작업들을 자동화하는 작업을 일컬어 CASE라고 한다.

+ **구 프 자 정 분**

> 구조적 기법 
>
> 프로토 타이핑 기술
>
> 자동 프로그래밍
>
> 정보 저장소 기술
>
> 분산처리 기술



### 유스케이스

**연관** 관계

**확장** 기본 수행시 특별조건 수행

**포함** 기능 포함

**일반화** 상속

**그룹화** 단순화

# 3장 애플리케이션 설계

---

## 소프트웨어 아키텍쳐



### 소프트웨어 아키텍쳐

+ 소프트웨어의 골격이 되는 기본 구조이자 소프트웨어를 구성하는 요소들 간의 관계를 표현하는 시스템의 구조 또는 구조체
+ 좋은 품질 유지를 위해 사용자의 기능/비기능적 요구사항을 반영하고 구현한다.

> **기능적 요구사항:** 시스템이 갖춰야하는 필수요구사항
>
> **비기능적 요구사항:** 그외 품질관련 제약요구



+ **소프트웨어 아키텍쳐의 기본 원리로 모듈화 , 추상화 , 단계적 분해 , 정보 은닉 이 있다.**





### 모듈화

+ 소프트웨어의 성능 , 수정 및 재사용 , 유지관리가 용이하도록 시스템의 기능들을 모듈단위로 나누는것

> **모듈:** 특정기능을 처리하는 코드 집합





### 추상화

+ 전체적이고 포괄적인 개념을 추상적으로 설계한후 세분화하고 구체화한다.

> **과정 추상화:** 전체 흐름을 파악하도록 추상화 (자세한 내용은 정의 x)
>
> **데이터(자료) 추상화:** 데이터 구조를 파악하도록 추상화 (자세한 내용은 정의 x)
>
> **제어 추상화:** 이밴트 발생의 절차나 방법을 추상화 (자세한 내용은 정의 x)





### 단계적 분해

+ 상위 개념부터 하위 개념순으로 점차 세분화하며 구체화 시키는것

> 전체 기능을 추상화하고 알고리즘 자료구조 등 구체화 방안을 결정시키는것





### 정보 은닉

+ 한 모듈 내부에 포함된 절차와 자료를 은닉해 다른 모듈이 접근하거나 변경하지 못하게 하는것





### 아키텍쳐 품질 속성

+ 아키텍쳐가 요구수준의 품질을 보장하게 설계되었는지 3가지 측면으로 평가하는것

> **시스템 품질:** 성능, 보안 , 가용성 , 기능성 , 사용성 , 변경용이성 , 확장성 
>
> **비즈니스 품질:** 시장 적시성 , 비용과 혜택 , 예상 시스템 수명 
>
> **아키택쳐 품질:** 기념적 무결성(일관적으로 정확) , 정확성 , 완결성 , 구축 가능성 





### 소프트웨어 아키텍쳐 설계과정

+ 설계목표설정 - 시스템 타입 결정 - 아키택쳐 패턴 적용(설계)  - 서브시스템구체화 - 검토

> **시스템타입에 의한 설계:** 대화형 , 반응형 등 
>
> **협약에 의한 설계 :** 컴포넌트 설계시 3개의 만족되어야하는 조건을 명세후 설계





## 아키텍처 패턴



### 아키텍처 패턴

+ 아키텍쳐를 설계할때 참조할 수 있는 예제

> **아키텍쳐 패턴의 종류:** 레이어패턴 , 클라이언트-뷰 패턴 , 파이프-필터 패턴 , 모델-뷰-컨트롤러 패턴 등등





### 레이어 패턴

+ 시스템을 계층으로 구분(특정 계층만 유지보수 가능)
+ 상위는 하위의 서비스 제공자
+ 마주보는 두 계층만 상호작용(변경이 용이)
+ **대표적 모델:** osi 참조 모델



### 클라이언트-서버 패턴

+ 서버와 클라이언트를 분리하는 구조
+ 사용자는 클라이언트하고만 소통
+ 서버와 클라이언트는 서로 통신을 위한경우 빼곤 독립적



### 파이프-필터 패턴

~~~
송신 - 필터 - 필터 - 필터 - 수신
      |--------파이프------|
~~~

+ 앞 시스템의 결과물 즉,데이터 스트림(흐름)을 필터를 거쳐 파이프를 통해 다음 시스템에 전송하는 것
+ 시스템이 데이터를ㅇ

> 필터는 재사용성,확장성이 좋다.
>
> 필터의 배치에 따라 다양한 파이프라인 구축가능
>
> 데이터 변환, 동기화에 사용된다(오버해드있음)



+ **대표적 모델:** UNIX 쉘



### MVC

+ 여러개의 뷰가 필요한 대화형 어플리케이션에 적합





## 객체지향



### 객체지향 

+ 개체를 하나의 객체로 만들어 조립하여 소프트웨어를 개발
+ 객체, 클래스 , 캡슐화 , 상속 , 다형성, 연관성



### 연관성

+ **연관화:** 2개 이상의 객체가 상호 관련되어 있음을 의미함
+ **분류화:** 동일한 형의 특성을 갖는 객체들을 모아 구성
+ **집단화:**  관련 객체를 모아 상위객체 구성(부분-전체)
+ <u>**일반화:** 자손의 공통 성질들로 상위 객체를 구성(인터페이스 설계나, 부모 클래스 생성)</u>
+ <u>**특수화/상세화:** 상위 객체로 부터 자손객체를 생성 -상속이나 구현</u>



### 객체지향 분석

+ 사용자의 요구사항을 분석해 <u>클래스,속성,의존관계 등을 정의하여 모델링</u>하는것



### 객체지향 분석 방법론

***럼바우**

+ 일반적으로 사용됨
+ 객체,동적,기능 모델순으로 나눠 수행

> **객체 모델링** 
>
> + 객체 식별
> + 연관관계 식별
>
> **동적 모델링**
>
> + 상태 다이아그램을 이용
> + 시간에 흐름에 따른 객체의 변화(관계,동작)을 모델링
>
> **기능 모델링**
>
> + 자료흐름도를 이용
> + 자료 흐름을 중심으로 처리과정을 표현

**부치**

+ **거시적(전체) 분석 방법과 미시적(세부) 분석** 방법을 사용
+ 클래스와 객체를 분석 및 식별

**jacobson**

+ **use case** 즉 사용자와 소통을 강조하는 분석법

**coad**

+ **E-R다이아그램**을 사용해 객체의 행위를 모델링
+ 객체 식별, 구조식별,주제정의 등

**wirfs**

+ 분석 설계간 구분이 없고 고객 명세서를 평가해 설계까지 연속적으로 수행



### use case

연관: 관계

확장: 특별조건







### 객체지향 설계 원칙

+ SOLID

**SRP 단일책임 원칙**

+ 객체는 높은 응집도 , 낮은 결합도

**OCP 개방-폐쇄 원칙**

+ 기존 코드 변경없이 기능이 추가될수있어야함
+ 인터페이스에 구현체를 갈아끼우는 DI가 대표적

**LSP 라스코프 치환 원칙**

+ 상위 타입은 항상 하위 타입으로 교체 가능해야한다.
+ 하위 구현체는 모든 상위를 구현해야한다.

**ISP 인터페이스 분리 원칙**

+ 필요없는것을 구현하도록 강요하지 않아야함

**DIP 의존 역전 원칙**

+ 구체 클래스 대신 상위 추상타입이나 인터페이스를 의존해야한다
+ 일방향의존관계여야한다.





## 모듈



###  모듈

+ 모듈화를 통해 분리도니 시스템의 각 기능들

> 루틴: 기능명령의 집합
>
> 메인루틴: 핵심루틴
>
> 서브루틴: 핵심루틴을 위해 중간중간 호출되는 루틴



+ ***결합도는 낮게 , 응집력은 높게**

> 결합도: 다른 모듈간의 연관도
>
> 응집도: 정보 은닉의 확장개념 내부요소끼리의 응집력



+ 강한 결합도 순서

> 자료(데이터) < 스탬프(자료구조) < 제어 < 외부 < 공통 < 내용



+ 강한 응집도 순서

> 기능 < 순차(다음활동의 입력데이터) < 교환(통신) < 절차(순차적 수행) < 시간 < 논리(유사성) < 우연(연관없는것들끼리)



### 팬인 팬아웃

> **팬인**
>
> 어떤 모듈 A 을 호출하는 모듈수
>
> **팬아웃**
>
> 어떤 모듈 A가 호출하는 모듈수



## 공통 모듈



### 공통모듈

+ 여러 프로그램에서 공통적으로 사용할수있는 모듈

+ 공통 모듈을 만들때는 다음과같은 명세 기법을 준수해야한다.

> **정확성** 정확한 작성
>
> **명확성** 중의적이지않게 명확히 작성
>
> **완전성** 필요한 모든것을 기술
>
> **일관성** 공통기능간 충돌이 없게 작성
>
> **추적성** 관련 관계를 파악할수있도록 작성



### 재사용

+ 기존 모듈을 재구성하는것
+ 규모에따른 분류

> **함수 및 객체**
>
> + 메서드 단위 소스코드 재사용
>
> **컴포넌트**
>
> + 여러 클래스로 작성되는 실행코드 기반 모듈
> + 컴포넌트 자체 수정없이 인터페이스 기반 재사용
>
> **애플리케이션**
>
> + 공통 기능 어플리케이션 공유해서 재사용



### 테스트 단위

테스트 스텁: 단순 기능 수행

테스트 드라이버: 모듈호출

테스트 슈트: 테스트케이스 집합

테스트 케이스: 테스트케이스



### 코드

+ 자료를 쉽게 추출하기위해 코드를 부여하는것

> 식별가능 , 분류가능 , 배열가능 , 표준화 가능(특정기준에 맞춰 표현) , 간소화 가능 해야함



+ 코드 종류

> **순차코드** 수를 부여 , 순서코드
>
> **블록코드** 블록으로구분
>
> **10진코드**  0~9까지 항목을 10진 분류하고 각 분류에서 일련번호를 추가해 완성
>
> **그룹분류코드** 대분류 중분류 소분류로 구분하고 그룹안에서 일련번호 부여
>
> **연상코드** 관계있는 숫자나 문자를 이용
>
> **표의숫자코드 ** 대상의 물리적 수치를 그대로반영(키 몸무개등)
>
> **합성코드** 여러코드를 합쳐서 완성





## 디자인 패턴



### 디자인패턴

+ 모듈의 역할이나 세부 코드를 작성하는 수준의 참고예제

~~~
아키택쳐 패턴: 전체 시스템구조를 설계하기 위한 참조모델
디자인패턴: 컴포넌트나 그 안에 세부적인 로직 설계를 위한 참조모델
* 몇몇 디자인패턴들은 아키택쳐 패턴을 구현하는데 사용된다.
~~~



### 디자인패턴의 장점

+ 범용적인 패턴으로 로직설계파악이 용이함
+ 검증된 구조로 시간과 비용 절약
+ 유연한 대처가 가능
+ ***객체지향기반 어플리케이션에만 어울린다**.



### 디자인패턴 종류

**생성패턴**

+ 객체의 생성에 관한 패턴
+ 생성과 참조를 캡슐화 하여 유연성을 보장
+ 종류

> **추상팩토리**
>
> **팩토리 메서드**
>
> **빌더**
>
> **프로토타입**
>
> **싱글톤**



**구조패턴**

+ 클래스나 객체를 조합해 더 큰 구조로 만드는 패턴
+ 복잡한 구조의 시스템을 쉽게 만들수있다.
+ 종류

> **어댑터**
>
> **브리지**
>
> **컴포지트**
>
> **데커레이터**
>
> **퍼씨드**
>
> **플라이웨이트**
>
> **프록시**



**행위패턴**

+ 객체간 상호작용 책임 분배방법을 정의
+ 하나의 객체로 수행할수없는 작업을 여러객체로 결합도가 최소화되도록 분배함
+ 종류

> **책임 연쇄**
>
> **커맨드**
>
> **인터프리터**
>
> **반복자**
>
> **중재자**
>
> **메멘토**
>
> **옵서버**
>
> **상태**
>
> **전략**
>
> **템플릿 메소드**
>
> **방문자**





# 4장 인터페이스 설계

---

 



## 시스템 인터페이스 요구사항 분석



### 시스템 인터페이스 

+ 독립적인 시스템끼리 상호작용하기위한 접속 방법이나 규칙



### 시스템 인터페이스 요구사항 분석 순서

~~~
요구사항 수집 - 관련 자료 수집 - 기능/비기능으로 요구사항으로 분류 - 조직화 - 요구사항 명세 구체화 - 관계자에게 전달
~~~



### 요구사항 검증 방법

**동료검토:** 동료가 검토

**워크스루:** 미리 배포하고 검토해보고 짧은 회의를 통해 검토

**인스팩션:** 다른 전문가가 검토

**프로토타이핑:** 프로토타입으로 검토

**테스트설계:** 테스트케이스로 검토

**CASE 도구 활용:** 일관성 분석을 통해 표준 준수여부



### 인터페이스 요구사항 주요 검증 항목

완전성,일관성,명확성,기능성,검증가능성,변경용이성,추적가능성



### 인터페이스 처리유형

**실시간 방식**

**지연처리 방식: ** 매건 처리하는 비용이 높을때

**배치방식:** 대용량 데이터를 처리할때







### 미들웨어

+ 분산컴퓨팅 환경에서 서로 다른 기종간의 연결을 통해 원만한 통신이 가능하도록 하는 소프트웨어
+ 종류: DB , RPC , MOM ,WAS 등

> **DB**
>
> + 데이터베이스와 연결 
> + 2-TIER 아키텍쳐
>
> **RPC(Remote Procedure Call)**
>
> + 원격 프로시저 호출
>
> **MOM**
>
> + 메세지 지향 
> + 데이터 동기
>
> **TP-Minitor**
>
> + 트랜첵션 모니터링
>
> **ORB**
>
> + 객체지향 미들웨어 
> + CORBA 표준스팩구현
>
> **WAS**
>
> + 웹환경구축  (클라이언트/서버 환경구축 아님)

+ **미들웨어 솔루션 식별:** 사용될 미들웨어 솔루션을 확인하고 목록작성

  > 아키텍쳐 구성정보
  >
  > 구매내역
  >
  > 솔루션 목록 작성 및 누락 이나 오류 확인



+ **미들웨어 솔루션 명세서 작성:** 솔루션 식별에 작성한 목록의 상세를 작성















































































































