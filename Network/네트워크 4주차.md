# 이메일과 SMTP

---

![image](https://user-images.githubusercontent.com/68331041/133955115-139d606e-e6bd-42d7-a80b-32096e826bed.png)

#### **이메일 전송 과정**

> ① 송신자 UserAgent 에서 메일 작성 후 메일 서버로 전달(**SMTP**)
> ② 송신자 **메일 서버**의 출력 메시지 **큐**(outgoing message queue)에 저장
> ③ **수신자 메일 서버**로 전송(**SMTP**)
>
> ④ 전송 불가시 **30분 단위로 재전송 시도**, 정해진 **기간 동안 전송 불가시 중단** 및 송신자에게 통보
> ⑤ 수신자 메일 서버의 수신자 **메일박스(mailbox)에 저장**
>
> ⑥ 수신자 UserAgent 에서 메일 서버의 메일박스의 메일 읽기 및 관리 (**NO** SMTP)



이메일 전송프로토콜은 **SMTP**이나 웹 이메일의 경우 **HTTP**를 쓰기도 한다.



**SMTP**

> **클라이언트-서버 프로토콜**
>
> > 클라이언트 : 송신 메일 서버/UA
> > 서버 : 수신 서버 메일/송신 메일 서버
>
> + 송신자 UserAgent  가 Mail Server로 보낼때 SMTP사용
>
>   송신 Mail Server 가 수신 Mail Server로 보낼때 SMTP사용
>
>   수신자 UserAgent 가 Mail Server에서 메일을 읽어드릴때는 SMTP사용이 **아니라** 그냥 읽어감
>
>   
>
> **TCP 사용**
>
> >  신뢰 전송
> > 서버 포트번호 : 25
>
> <img src="https://user-images.githubusercontent.com/68331041/133955744-829e5238-5dd0-4c7f-96bd-049098774c43.png" alt="image" style="zoom:50%;" />
>
> **ASCII 텍스트 프로토콜**
>
> > 명령어 : ASCII 그래픽문자 + 제어문자
> > 메시지 : ASCII 그래픽문자 + 제어문자

**HTTP**

+ Pull Protocol //요청하여 서버로부터 정보를 받아오는 프로토콜
+ Push Protocol 도 가능

**SMTP**

+ Push Protocol //서버로 정보를 보내서 저장하는 프로토콜
+ 메일 특화 프로토콜로 간단하게 멀티전송에 탁월하다.



![image](https://user-images.githubusercontent.com/68331041/133956409-e27cec9c-b410-43d8-8d36-ce7a491d4373.png)

송수신 메일서버는 **항상 가동중**   수신자 UA는 **필요할때만 가동**됨으로 수신자 메일 서버에서 **Push Protocol 을사용할수가 없다**. 따라서 Pull Protocol 을 사용한다.



# DNS(Domain Name System)

---

**사용자 접근성과 편의성을 위해 HOST들 에게 계층 시스템을 통해 Unique한 Name을 부여하는 것**



#### **[분산계층구조 DNS]**

![image](https://user-images.githubusercontent.com/68331041/134792361-8c0ac0b3-3635-4c32-b323-897bae0802bb.png)

**도메인 구조**

> 최상위 도메인 : 7개 일반 도메인: .com, .org, .net, .int, .edu, .gov, .mil
>
> 국가 도메인 : .kr, .jp, .uk,
>
> 중간 도메인 : .ac, .gov, .re., .or,
>
> 책임 도메인 : .koreatech.ac.kr
>
> 호스트 도메인 : sce.koreatech.ac.kr, scpark.koreatech.ac.kr



### DNS의 장점

> HOST의 IP주소는 변경되거나 회수되는경우가 있다. 이때 IP로 접근한다고 하면 **참조자 들에게 HOT IP의 변경을 하나하나 다 알려줘야한다.(ERROR!)**, 이때 DNS를 사용하면 **DNS는 고유한 HOST만의 별칭 값**이기 때문에 **IP가 변경되어도  접근에 영향을 받지 않는다.**
>
> DNS(**IP**)  //IP를 변경이 발생하면 IP값을 치환환해주기만 하면 된다. 



DNS는 초기에 중앙집중구조였다.

> 하나의 서버가 모든 DNS 질의(queries) 처리
>
> **문제점**
>
> > A single point of failure : 중앙 서버 고장 시 전체 네트워크 고장
> > Traffic volume : 중앙 서버에 부하 집중
> > Distant centralized database : 원거리 중앙 서버의 응답 지연시간 증가
> > Maintenance : 중앙 서버 유지 보수 어려움

#### **이후 분산계층구조로 변경되었다.**

> **중앙서버의 집중도를 분산시켜 부하를 줄일수있다.**
>
> 여러 계층에서 분산된 처리를 함으로 연산속도,신뢰도가 향상된다.
>
> 확장과 유지보수에 용이하다.

[분산계층구도 관계도]

![image](https://user-images.githubusercontent.com/68331041/134792894-55b20eee-b062-43ea-b487-459103584192.png)

**루트 서버(Root server)**
 일반적으로 중간 서버(TLD 서버)에 대한 IP 주소 제공

**TLD 서버**
 최상위 도메인(Top Level Domain)에 대한 DNS 서비스 담당
 일반적으로 책임(authoritative) DNS 서버의 IP 주소 제공

**책임(authoritative) DNS 서버**
 특정 호스트의 도메인명 정보를 유지하고 있는 서버

---

**지역(local) DNS 서버**
 DNS 서비스를 요청하는 **"클라이언트 호스트가 소속된 DNS 서버"**
 소속된 호스트들의 DNS 서비스 요청 대행



**[DNS 서비스 제공 방식]**

![image](https://user-images.githubusercontent.com/68331041/134793005-548a46ae-3cb7-4a02-bea3-2615dbc202f2.png)

+ **반복적 질의 방식도 있다.**



### **DNS 캐싱(caching)**

특정 서버가 다른 서버에게 질의를 하고 응답을 받으면 이 정보를 클라이
언트 방향으로 전달하기 전에 자신의 **캐쉬(Cache) 메모리에 저장**
해당 서버가 **동일한 도메인명**에 대한 해석을 **요청**하는 질의를 수신하면
다른 서버에게 질의 메시지를 전달하는 대신 **캐쉬 메모리 정보를 응답**

+ **캐싱 정보는 일정 시간(TTL-Time To Live)이 지나면 자동적으로 삭제**

