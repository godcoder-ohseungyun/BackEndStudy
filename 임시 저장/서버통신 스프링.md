







### 

# 서버간 통신의 시작 RestTemplate

---

## 개요

작은 규모의 서비스를 개발한다면 서버와 클라이언트 간 1:1 상호작용이 대부분임으로 서버를 1개만 만들어도 충분하다.

**하지만** 

더 큰 서비스가 될 수록 서버를 여러개로 `스케일 아웃` 하여 운영해야 할 것이다.

서버를 여러개로 분산하기위해 가장 필요한것은 `서버간의 통신을 어떻게 하는가?` 일 것이다.



**아래와 같은 두가지 개념을 기본으로 자료를 조사했다.**

모든 서버들은 REST규칙을 준수해서 RESTful하게 개발되어있다. 나 또한 RESTful 서버를 만들고 있다.

> URI 와 HTTP method를 이용해 request&response

서버간 통신엔 Json 데이터 포멧을 사용할것이다.

> 수신측과 송신측의 기종,사용언어에 제한없이 JSON 데이터 포멧을 이용하면 유연하게 통신할수있다.
>
> HTTP body에 실어서 주고받음



**서버간 통신 구조**

![image-20220104113514712](C:\Users\afrad\AppData\Roaming\Typora\typora-user-images\image-20220104113514712.png)

1. 클라이언트가 서버1에게 요청한다.

~~~
GET www.server1.com
~~~

2. 서버1은 요청을 받으면 서버2에게 클라이언트 데이터를 요청한다.

~~~
GET www.server2.com
~~~

3. 서버2는 데이터를 생성해서 서버1에게 응답한다.
4. 서버1은 서버2로부터 받은 데이터를 클라이언트에게 응답한다.



**그래서 스프링으론 이걸 어떻게 구현하나?**

Spring boot에서는 다른 서버의 API endpoint를 호출할 때 **RestTemplate**을 많이 쓴다.

>  Endpoint란 API가 서버에서 자원(resource)에 접근할 수 있도록 하는 URL

즉, `다른 RESTful 서버로부터 데이터를 요청`할때 RestTemplate이라는 클래스를 사용한다는 것이다.

# RestTemplate

---

스프링에서 제공하는 HTTP 통신 기능을 쉽게 사용할수있게 설계되어있는 `*템플릿`이다.

> `*템플릿이란?`
>
> 질이 다른 코드 중에서 변경이 거의 일어나지 않으며 일정한 패턴으로 유지되는 특성을 가진 부분을 자유롭게 변경되는 성질 을 가진 부분으로부터 독립시켜서 효과적으로 활용할 수 있도록 하는 방법.

HTTP 서버와의 통신을 단순화 하고 RESTful 원칙을 지켜서 구현되어있다.

동기방식으로 작동하며, 비동기는 `AsyncRestTemplate`가 있음

RestTempate 클래스는 REST 서비스를 호출하도록 설계되어있고 HTTP 메소드에 맞게 여러 메소드를 제공하고있다.



#### RestTempate 를 사용하면 RESTful 서버와 HTTP  request&response가 가능하기때문에 다른 서버에게 데이터를 받아올수있다.



**RestTempate Class**

org.springframework.web.client.RestTemplate

![image-20220104110932516](C:\Users\afrad\AppData\Roaming\Typora\typora-user-images\image-20220104110932516.png)

> RestTempate 클래스는 **REST 서비스를 호출**하도록 설계되어있고 **HTTP 메소드에 맞게 여러 메소드를 제공**하고있다.
>
> HTTP 서버와의 통신을 단순화 하고 RESTful 원칙을 지켜서 구현되어있다.
>
> > HTTP 메서드에 따라 호출 메서드가 존재한다.



### RestTempate 동작 원리

- HttpClient는 HTTP를 사용하여 통신하는 범용 라이브러리
- RestTemplate는 HttpClient를 추상화(HttpEntity의 json, xml 등)해서 제공

![image-20220104121114479](C:\Users\afrad\AppData\Roaming\Typora\typora-user-images\image-20220104121114479.png)

1. 어플리케이션이 RestTemplate를 생성하고, URI, HTTP 메소드 등의 헤더를 담아 요청
2. RestTemplate는 HttpMessageConverter를 사용하여 requestEntity를 요청 메세지로 변환
3. RestTemplate는 ClientHttpRequestFactory로 부터 ClientHttpRequest를 가져와서 요청을 보냄
4. ClientHttpRequest 는 요청메세지를 만들어 HTTP 프로토콜을 통해 서버와 통신
5. RestTemplate 는 ResponseErrorHandler 로 오류를 확인하고 있다면 처리로직을 태움
6. ResponseErrorHandler 는 오류가 있다면 ClientHttpResponse 에서 응답데이터를 가져와서 처리
7. RestTemplate 는 **HttpMessageConverter** 를 이용해서 응답메세지를 java object(Class responseType) 로 변환
8. 어플리케이션에 반환



HttpMessageConverter를 이용해서 요청 및 응답시 자동으로 자바 객체를 JSON으로 컨버팅 해준다.

아주 편리하다.



스프링에서 테스트하는 방법은 공식 가이드에서 충분히 이해할수있다.

https://spring.io/guides/gs/consuming-rest/



**테스트 프로젝트:** [MyGithub](#)



## Reference

---

[스프링 RestTemplate 정리(요청 함) (velog.io)](https://velog.io/@soosungp33/스프링-RestTemplate-정리요청-함)

