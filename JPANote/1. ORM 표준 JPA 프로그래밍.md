# JPA

---

 **DMBS의 방언**

> MySQL은 VARCHAR, Oracle은 VARCHAR2 등등
>
> SQL 표준을 지키지 않는 특정 데이터베이스만의 **고유한 방언이 존재**한다.
>
> JPA persistence 설정에서 어떤 DBMS를 사용할지 명시해 주면 알아서 Dialect 를 통해 번역해준다.



# JPA 핵심 요소

+ 객체와 관계형 데이터베이스 매핑하기

+ 영속성 컨텍스트



**JPA 엔티티 관리**

<img src="https://user-images.githubusercontent.com/68331041/133788495-ab4d5790-6eef-435f-bf3a-a2bbafc91ed0.png" alt="image" style="zoom: 50%;" />

```JAVA
EntityManagerFactory emf = Persistence.createEntityManagerFactory("hello"); //엔티티 매니저 팩토리는 "하나"만 생성해서 애플리케이션 전체에서 공유
//-> 엔티티 메니저들을 찍어내는 공장

EntityManager em = emf.createEntityManager(); //엔티티 매니저는 쓰레드간에 공유X -> 사용 후 패기

EntityTransaction tx = em.getTransaction(); //JPA의 모든 데이터 변경은 트랜잭션 안에서 실행

tx.begin();

/**
 * Member Jpa로 생성하기
 */
try {
    Member member = new Member();
    member.setId(1L);
    member.setName("회원1");

    em.persist(member); //DB에 즉시저장 X -> 엔티티를 영구 저장하는 징검다리 환경에 저장한다는 의미 -> "영속성 컨텍스트"

    tx.commit();
} catch (Exception e) {
    tx.rollback();
} finally {
    em.close();
}
```

**엔티티 매니저**를 통해서 **영속성 컨텍스트**에 **접근**



**엔티티의 생명주기**

> • 비영속 (new/transient)
> 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태 
>
> > 객체 생성
>
> • 영속 (managed)
> 영속성 컨텍스트에 관리되는 상태 
>
> > 객체를 persist
>
> • 준영속 (detached)
> 영속성 컨텍스트에 저장되었다가 분리된 상태 
>
> > 객체를 detach
>
> • 삭제 (removed)
> 삭제된 상태
>
> > 객체를 delete

### 영속성 컨텍스트

+ 객체 - **영속성컨텍스트** - DB
+ 일종의 징검다리로써 DB로 가기전 객체의 전반적인 관리를 담당한다.
+ 엔티티메니져를 통해 접근이 가능하며 persist() 로 영속시킨다.

> **영속**
>
> 객체정보를 영속성컨텍스트안에 존재하는 1차 캐시 와 쓰기지연저장소에 저장한다.

+ commit()시 영속성컨텍스트에서 관리하던 객체를 DB로 저장시킨다. 이를 **플러시**라고 한다.

~~~java
Member member = new Member();
    member.setId(1L);
    member.setName("회원1"); //비영속

    System.out.print;m("start");
    em.persist(member); //영속 컨텍스트에 영속 //여기가 아니라
    System.out.print;m("end");

    tx.commit(); //쿼리->DB  //여기서 디비로 저장이 이루어짐

//실행은 "start"
//       "end"
//       "DB저장"
~~~

**commit 해야 DB로 저장**되는 매커니즘 **그전엔 영속 컨텍스트에 보유**하고있다.

<img src="https://user-images.githubusercontent.com/68331041/133790646-c276c9b6-398e-40e8-a876-b22f04a2f58e.png" alt="image" style="zoom: 50%;" />



### 왜 이런 매커니즘?

**영속성 컨텍스트의 이점**

• 1차 캐시 

~~~JAVA
Member member = new Member();
member.setId("member1");
member.setUsername("회원1");

//1차 캐시에 저장됨
em.persist(member);  //영속성 컨텍스트 1차 캐시에 저장

//1차 캐시에서 조회
Member findMember = em.find(Member.class, "member1")
//DB까지 가지 않고 영속컨텍스트에서 영속된 객체들을 찾아서 반환해준다.
//영속컨텍스트에 없다면 DB에서 찾아서 영속시킨후 가져온다.
//캐시의 역할
//DB에 저장되기 전에도 사용이 가능하다.
    
tx.commit()
//DB에 저장
~~~

• 동일성(identity) 보장 

~~~JAVA
Member a = em.find(Member.class, "member1"); 
Member b = em.find(Member.class, "member1");
System.out.println(a == b); //동일성 비교 true
~~~

• 트랜잭션을 지원하는 쓰기 지연

~~~JAVA
//엔티티 매니저는 데이터 변경시 트랜잭션을 시작해야 한다.
transaction.begin(); // [트랜잭션] 시작

em.persist(memberA);
em.persist(memberB);
//여기까지 INSERT SQL을 데이터베이스에 보내지 않는다.-> 영속성 컨텍스트 안에 있는 쓰기지연 SQL저장소와 1차 캐시에 저장

//"커밋하는 순간 쓰기지연 SQL저장소로 부터 데이터베이스에 INSERT SQL을 보낸다."
transaction.commit(); 
~~~

• 변경 감지(Dirty Checking) 

~~~JAVA
// 영속 엔티티 조회
Member memberA = em.find(Member.class, "memberA");
// 영속 엔티티 데이터 , 수정하면 알아서 변경점 저장
memberA.setUsername("hi");
memberA.setAge(10);

//em.update(member) 이런 코드가 있어야 하지 않을까? -> NO,영속성 컨텍스트에서 즉시 수정이 가능하다.

transaction.commit(); 
~~~

> 영속성 컨텍스트에서 그전에 존재하던 **엔티티 스냅샷과 비교**하여 변경을 감지하여 **자체적으로 업데이트**한다.

• 지연 로딩(Lazy Loading)



### 플러시

영속성 컨텍스트의 변경내용을 데이터베이스에 반영

> em.flush() - **직접 호출** //즉시 DB에 적용해보고싶을때
>
> 트랜잭션 **커밋** - 플러시 **자동 호출** 
>
> **JPQL 쿼리** 실행 - 플러시 **자동 호출**
>
> > DB에 적용되지 않은 상태의 객체(쓰기지연 저장소에 있는 객체)들은 
> >
> > JPQL 쿼리 실행시 결과에 반영되지 않기때문에 자동으로 플러시한다.

영속성 컨텍스트를 비우지 않음 

영속성 컨텍스트의 변경내용을 데이터베이스에 동기화 



### 준영속

영속상태에서 객체를 제외시켜버리는것

영속성 컨텍스트가 제공하는 기능을 사용 못함

그간의 변경사항 추적 및 커밋조차 안된다. 

clear시 1차 캐시를 모두 지워버리기때문에 재 조회시 다시 1차 캐시로 DB로 부터 원본을 올린다. 



## JPA DDL자동 생성기능

+ **JPA**는 DBMS방언을 고려하여  **DDL을** 애플리케이션 실행 시점에 **자동 생성** 및 처리하는 설정을 가지고있다.

  > DDL: 데이터 조작어 ex)테이블생성 쿼리

  ~~~java
  //in persistence.xml 작성
  hibernate.hbm2ddl.auto value=" "
  /* 
  ======================value==========================
  create: 기존테이블 "삭제 후" 다시 생성 (DROP + CREATE) 
  create-drop: create와 같으나 종료시점에 테이블 DROP
  update: 변경분만 반영(운영DB에는 사용하면 안됨)
  validate: 엔티티와 테이블이 정상 매핑되었는지만 확인
  none: 사용하지 않음
  ====================================================
  */
  ~~~

+ ### 운영에는 절대 create, create-drop, update 사용하면 안된다. 

> 잘못 사용하면 기존 데이터를 모두 날릴수가 있다. 



# 엔티티 매핑



### **@Entity**

> **@Entity가 붙은 클래스는 JPA가 관리**
>
> JPA를 사용해서 **테이블**과 **매핑**할 **클래스**는 @Entity 필수
>
> **매핑할 클래스 조건**
>
> + 기본 생성자 필수
>
> + final 클래스, enum, interface, inner 클래스 사용X 
>
> > 저장할 필드에 final 사용 X

~~~java
@Entity(name ="name") //default class name //jpa관리
@Table(name="table name") //table과 매핑
~~~



# 필드와 컬럼 매핑



**매핑 어노테이션 정리**

~~~JAVA
@Id
@Column //컬럼 매핑
@Temporal //날짜 타입 매핑
@Enumerated //enum 타입 매핑
@Lob //BLOB, CLOB 매핑 -> 엄청 큰 StringType
@Transient //특정 필드를 컬럼에 매핑하지 않음(매핑 무시)
~~~

**핵심은 @Column**

+ Column 속성

![image](https://user-images.githubusercontent.com/68331041/133877592-11700815-f868-4ad7-ae2b-58ca40980fb3.png)

> @Enumerated:: **기본값 ORDINAL 사용 금지**
>
> > enum 수정시 순서도 변동이 생겨 기존 데이터들과 문제가 생긴다 **String으로 사용**하기.
>
> **@Temporal [중요!]**
>
> > LocalDate, LocalDateTime을 사용할 때는 생략 가능
> >
> > ### **java 11 에선 LocalDateTime 이라는 객체를 제공한다.!!**
>
> @Lob
>
> > 매핑하는 필드 타입이 문자면 CLOB 매핑, 나머지는 BLOB 매핑
> >
> > **CLOB**: String, char[], java.sql.CLOB 
> > **BLOB**: byte[], java.sql. BLOB 

# 기본키 매핑

~~~java
//@Id //id값 내가 직접 설정하는 경우 "@GeneratedValue 필요없음"
//@GeneratedValue  //id값 자동생성
@Id @GeneratedValue(strategy = GenerationType.AUTO)
private Long id;

/* 
@GeneratedValue(strategy = GenerationType.AUTO)
속성
• IDENTITY: 데이터베이스에 위임, MYSQL -> 1,2,3,...

• SEQUENCE: 데이터베이스 시퀀스 오브젝트 사용, ORACLE 
  > @SequenceGenerator 필요
  
• TABLE: 키 생성용 테이블 사용, 모든 DB에서 사용
  > @TableGenerator 필요
  
• AUTO: 방언에 따라 자동 지정, 기본값
*/


~~~



# 기본키 전략

• 기본 키 제약 조건: null 아님, 유일, 변하면 안된다.

• 미래까지 이 조건을 만족하는 **자연키는 찾기 어렵다**. 대리키(대
체키)를 사용하자. 

>예를 들어 **주민등록번호도** 기본 키로 적절하기 않다. 

• **권장**: Long형 + 대체키 + 키 생성전략 사용







---

# 관계 매핑

### 연관관계 매핑시 고려사항 3가지

> **다중성**
>
> + 관계 1:1? 1:n?
>
> **단방향, 양방향**
>
> + 단뱡향으로 충분히 구현가능, 필요시에만 양방향으로 Upgrade!
>
> **연관관계의 주인**
>
> + 외래키 삽입 삭제의 권한을 갖는 테이블을 결정하자, 반대편 테이블은 조회만 가능하다. 

### 다대일 [N:1] 

> 가장 기본적인 연관관계 설정

### 일대다 [1:N] 

> 잘 쓰이지 않는다, 다대일 관계에서 설계가 잘못되었을 경우가 많음

### 일대일 [1:1] 

> 다대일 관계와 설정은 동일하나 unique가 추가되어야 한다. 여러값이 오면 x

### 다대다 [N:M]

> #### **실무에서 @ManyToMany 사용 금지!!       관계 테이블 과@ManyToOne 으로 분할해서 사용**
>
> 다대다 관계는 **단순 매핑하면 절대 X** 
>
> **단순화가 불가능**한 관계도이다.
>
> 중간에 **관계테이블이 존재**해야하는데, 이 테이블이 날짜 등등 **별개의 데이터를 가질 확률이 높음**
>
> **"**테이블1 **1:n** 관계 테이블  **n:1** 테이블2**"** 이렇게 나누어서 **다대일 연관관계 설정**으로 만든다.

#### **슈퍼-서브 매핑**

> **조인 전략**
>
> > **장점**
> > • 테이블 정규화
> > • 외래 키 참조 무결성 제약조건 활용가능
> > • 저장공간 효율화
> > **단점**
> > • 조회시 **조인을 많이 사용, 성능 저하**
> > • 조회 쿼리가 복잡함
> > • 데이터 저장시 INSERT SQL 2번 호출
>
> ![image](https://user-images.githubusercontent.com/68331041/133998377-b497e4e4-1dec-4e84-93fd-f5cd5f7ba085.png)
>
> **단일 테이블 전략**
>
> > **장점**
> > • 조인이 필요 없으므로 일반적으로 조회 성능이 빠름
> > • 조회 쿼리가 단순함
> > **단점**
> > • 자식 엔티티가 매핑한 컬럼은 모두 **null** 허용
> > • 단일 테이블에 모든 것을 저장하므로 테이블이 커질 수 있다. 상황에 따라서 조회 성능이 오히려 느려질 수 있다
>
> ![image](https://user-images.githubusercontent.com/68331041/133998344-827407f3-6864-4d6e-b18f-f63c5c3dae6f.png)
>
> **구현 클래스마다 테이블 전략**
>
> > 이 전략은 데이터베이스 설계자와 ORM 전문가 둘 다 추천X 
>
> ![image](https://user-images.githubusercontent.com/68331041/133998282-b98ab87e-379a-4222-91d1-139e53eaee12.png)

#### **@MappedSuperclass**

> ![image](https://user-images.githubusercontent.com/68331041/133999176-bd2330c3-6620-4e75-82b7-3514afb693bf.png)
>
> 객체마다 속성들이 겹칠때 **겹치는 속성**들을 **따로 부모 객체로** 만들어서 **코드중복을 없앨수있다.**
>
> **편리하게 공통되는 속성을 쓸수있다.**
>
> 자식 클래스에 단순히 매핑 정보만 제공, 즉 부모에 데이터가 **상속되는 개념이 아니다.** 조회 검색도 당연히 안된다. 
>
> 추상클래스로 생성하는것을 권장 껍데기만 쓰이기 때문



