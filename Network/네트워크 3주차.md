# 응용계층원리

---



**네트워크 응용 서비스**

> 네트워크 통신 서비스를 사용/응용하여 **사용자에게 제공되는 서비스**



**네트워크 구성**

> **호스트** : 응용 정보(예, URL, HTML 페이지)를 교환하고 해석하고 처리
>
> **스위치(라우터)** : 네트워크 장치를 연결하고 패킷을 교환

**패킷**

> 응용 정보를 **효율적인 교환**을 위해 **작은 크기로 나눈 정보단위**
>
> **호스트**에서 분할 및 조립되어(reassembly) 응용 계층에서 처리





**네트워크 응용 구조 유형**

> #### 클라이언트-서버 구조(Client-server architecture)
>
> > request - response 구조
> >
> > **클라이언트는 요청**
> >
> > > 서버에게 응용 서비스 요청
> > > (클라이언트간 통신 No)
> > > 필요할 때만 작동
> > > 동적(임시) IP 주소 사용 가능
> >
> > **서버는 응답**
> >
> > > **다수의 클라이언트**의 서비스 요청**에 응답**
> > > 항상 작동(Always-on)
> > > 고정 (또는 그에 준하는) IP 주소 사용
> > > 확장성(scalability) 문제
>
> 
>
> #### P2P 구조(Peer-to-Peer architecture)
>
> > 임의의 호스트간에 **직접**
> > **통신**하고, 각 **호스트는 클라이언트**
> > **역할과 서버 역할을 동**
> > **시에 수행**하며,  호스트간의 관계가 **대등**
> > (peer-to-peer)
>
> > **장점**
> >
> > > 서버 의존성이 없음 
> > >
> > > 구축 및 관리 비용이 낮음 
> > >
> > > 자가 확장성(Self-scalability) 
> >
> > **문제점**
> >
> > > 보안 취약성(Security) 
> > >
> > > 낮은 신뢰성(Reliability) 
> > >
> > > 낮은 성능(Performance)



### 소켓

응용 프로세스가 **네트워크로 메시지를 송신하고 수신하는 통로 자료구조**

+ **트랜스포트 계층** 상에서 구현



**소켓 API**

소켓 자료구조를 사용하여 통신 서비스를 제공하는 프로그램 **인터페이스**
 API를 사용하여 응용 프로그램 구현



# HTTP 동작원리

---

**HTTP(하이퍼텍스트트랜스퍼프로토콜)**

> 웹 브라우저와 웹 서버간의 주고받는 **Request & Response 데이터**를 정의한 **프로코톨**
>
> 실제로는 트랜스퍼 계층의 **TCP connection** 을 통해 전송된다.

**웹 서버**

> DB와 요청처리 소프트웨어
>
> > MVC 컨트롤러, JPA

**웹 브라우저**

> 웹 페이지 요청 및 응답 페이지 디스플레이



**HTTP Request**

>  웹 사용자의 요청(**URL 입력 또는 하이퍼링크 클릭**)으로 웹 브라우저에 의 해 생성되는 메시지
>
>  웹 서버의 웹 객체 URL과 해당 웹 객체 처리 방식 정보 제공
>
>  하위 계층의 TCP 연결을 통해 웹 서버에게 전송

**HTTP response**

>  웹 브라우저의 요청으로 웹 **서버에 의해 생성**되는 메시지
>
>  **수신한 URL**에 해당되는 웹 객체와 웹 객체 속성 **정보 제공**
>
>  하위 계층의 TCP 연결을 통해 웹 브라우저에게 전송

**비상태형 프로토콜(stateless protocol)**

> HTTP request 메시지와 HTTP response 메시지 간의 관계 정보가 웹 서버에 저장되지 않음
>
> 서버를 자유롭게 선택할수있어 예상치 못한 오류에도 대처할수있다.



# TCP/IP SOCKET



**3-way-handshaking**

![image](https://user-images.githubusercontent.com/68331041/133071604-f1fb0065-670b-44ed-a1cc-478d099da495.png)

1.SYN 요청:TCP Connection 요청

2.SYN 응답: 허락하면 연결완료

3.이제 ACK 요청을통해 HTTP request 보내고 응답받을수있다.



**비지속 연결 HTTP**

TCP연결후 한쌍의 요청 응답후에 TCP연결을 해제한다.

병렬로 여러 통신을 동시에 할수있다.

TCP연결에 지연되는 시간이 항상 발생한다.



**지속 연결 HTTP**

TCP연결후 일정 조건동안 연결을 유지한다.

TCP연결 지연시간을 아낄수있지만 사용하지 않을때도

연결이 유지되어있어 소켓 낭비가 발생한다. 

한번의 연결로 여러번 통신을 할수있다는 장점



# WEB SOCKET

쌍방향 통신 가능

---

# HTTP: message,cookie,cash



#### **요청 HTTP 구조**

![image](https://user-images.githubusercontent.com/68331041/133356394-e78b7b49-9618-4f7f-a370-754d99873c76.png)

요청라인 + 헤더라인 + 공백 + 바디

> 예시)
>
> <img src="https://user-images.githubusercontent.com/68331041/133357282-25790572-3df5-4b77-b613-970836023ed7.png" alt="image" style="zoom:33%;" />



**요청라인**

> HTTP method 정보 (GET POST PUT etc..)
>
> > GET : **body 정보 없이** 객체 요청(url로 파라미터 전송)
> >
> > POST : **body 입력 정보와 함께** 객체 요청
> >
> > HEAD : 헤더 정보만 요청
>
> URL 정보
>
> VERSION 정보

**헤더라인** 

> 서비스를 어떻게 처리해야하는지 명시

**공백** 

> 공백필요

**바디**

> 전송할 실제 데이터

---

#### **응답 HTTP 구조**

![image-20210915105342918](C:\Users\afrad\AppData\Roaming\Typora\typora-user-images\image-20210915105342918.png)

응답이기 때문에 http method,URL등 **요청라인이 없고**

**응답의 정보를 담아**내는 **Status line이 존재**한다,

> 200,300,400,500 상태코드 
>
> ![image](https://user-images.githubusercontent.com/68331041/133357838-a9060e51-a65f-4e0a-b0a7-1dc9bd951097.png)



**상태라인**

> 응답의 상태를 나타냄 ex) 200 상태코드 등등

**헤더라인** 

> 서비스를 어떻게 처리해야하는지 명시 + 어떻게 처리했는지 ex)갱신시간 등

**공백** 

> 공백필요

**바디**

> 전송할 실제 데이터

---

#### **웹 쿠키**

서버는 브라우저에게 **유니크한 ID를 부여**한다. 이 ID를 가지고

브라우저는 **쿠키 저장소를 생성**, ID로써 서버가 브라우저가 누군지 알고있기때문에 브라우저는 서버와의 **통신**에 자신만의 **쿠키**와 저장정보를 **이용**할수있다. 

BUT, 서버에게 브라우저 개인정보 노출위험이 있다.

> 쿠키 저장소는 브라우저 수준에 있음 

---

#### **웹 캐시**

프록시 서버(대행서버) 를 이용하여  요청 메시지를 **중간 처리**

**request에 대한 응답**이 **프록시서버에 복사본이 존재**하면 **중간에서 대신 하여 송수신** 해준다.



브라우저 - **프록시 서버** - 서버

> 복사본이 있는경우 서버까지 갈 필요도 없이 프록시에서 응답을 받을수있기에 **응답시간이 단축**된다.



**생존주기가 존재**하며 생명주기가 말소되거나 응답의 내용이 변경된 경우 서버로 부터 **다시 최신화** 되어야한다.



