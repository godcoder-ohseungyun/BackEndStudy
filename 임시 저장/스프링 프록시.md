



# 스프링 프록시 사용(feat.로그추적기)

---

## 횡단 관심사

한 애플리케이션 전반에 로그를 남기는 기능은 특정 기능 하나에 관심이 있는 기능이 아니다. 애플리케이션의 여러 기능들 사이에 걸쳐서 들어가는 관심사이다.

이것을 바로 **횡단 관심사(cross-cutting concerns)**라고 한다. 



횡단 관심사를 분리해서 하나의 코드로 관리하는 것을 AOP라고 한다.



## 쓰래드 로컬

~~~
private ThreadLocal<TraceId> traceIdHolder = new ThreadLocal<>();
~~~

LogTrace를 만들때 ThreadLocal 이란 것을 사용한다.

LogTrace  ThreadLocalLogTrace의 필드 traceHolder에 `TraceId`를 유지한다.

> **이때,** 여러 쓰래드가 동시에 traceHolder에 접근하는 경우 서로 영향을 미친다.



ThreadLocal을 사용해서 동시성 문제를 해결할수있다.

> ThreadLocal을 사용해서 각 쓰래드별로 메모리저장소를 따로 지정해서 사용하도록 할수있다.
>
> ![image-20220207135306009](C:\Users\afrad\AppData\Roaming\Typora\typora-user-images\image-20220207135306009.png)
>
> 쓰래드 풀을 사용하는경우.  반드시 사용후 파기해야한다.
>
> > 쓰래드가 작업이 끝나고 쓰래드 풀로 복귀했을때 다른 작업을 위해 그 쓰래드가 재할당 될수있다.
> >
> > **이때,** ThreadLocal를 파기하지 않았으면 이전 작업내역 메모리를 그대로 사용하기때문에 문제가 발생할수있다.
> >
> > 꼭 작업이 종료되면 해당 쓰래드 풀을 제거하자.



## 프록시

로그를 찍기위한 코드를 컨트롤러에 추가한 모습이다.

원래 컨트롤러의 `핵심 로직과` 로그를 찍기위한 `서브 로직이 뒤섞여있는 모습`을 볼수있다.

~~~java
@RestController
@RequiredArgsConstructor
public class OrderControllerV3 {

    private final OrderServiceV3 orderService;
    private final LogTrace trace;

    @GetMapping("/v3/request")
    public String request(String itemId) {

        TraceStatus status = null;
        try {
            status = trace.begin("OrderController.request()");
            
            orderService.orderItem(itemId); //원래 핵심로직
            
            trace.end(status);
            return "ok";
        } catch (Exception e) {
            trace.exception(status, e);
            throw e;
        }
    }
}
~~~



### 로그를 찍고자하는 모든 곳에 저렇게 로그를 찍는 코드를 추가하면 "코드중복"이 너무 심하다.



`디자인패턴` 템플릿 메서드 패턴이나 전략 패턴을 사용해서 어느정도 "코드중복"을 줄일수있겠지만,

완전한 분리는 불가능하다.



**변하는 코드와 변하지 않는 코드를 분리하는것은 중요하다.**



### 프록시 패턴은?

[프록시 패턴](#https://onlyforus-blog.tistory.com/114?category=993144)을 이용하면 완전한 분리가 가능하다.

프록시 패턴을 이용하면 본 객체를 대신해서 클라이언트의 요청을 받고 본객체를 요청해 동작을 수행한다.

> 인터페이스 기반, 클래스 기반이 있다.



이 과정에서 `프록시에 로그를 찍는 서브 코드를 추가`하면 본 객체의 `핵심로직과 서브로직을 분리` 할 수 있다.

![image-20220207121250016](C:\Users\afrad\AppData\Roaming\Typora\typora-user-images\image-20220207121250016.png)



+ 스프링 빈에는 본 객체 대신 프록시 객체를 대신 저장하면 된다.





### 문제점: 본 객체의 수 만큼 프록시 객체를 생성해야한다.

> 본 객체가 수백개라면 프록시 객체도 수백개가 생성된다.



이런 문제를 `동적 프록시` 를 이용해 해결할 수 있다.



## 동적 프록시

*** 동적 프록시를 이해하기 위해서는 먼저 `자바의 리플렉션 기술`을 이해해야 한다**

> [자바 리플렉션 설명 보기](#https://velog.io/@mooh2jj/%EC%9E%90%EB%B0%94-%EB%A6%AC%ED%94%8C%EB%9E%99%EC%85%98reflection%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90) 
>
> 리플렉션 기술을 사용하면 클래스나 메서드의 메타정보를 동적으로 획득하고, 코드도 동적으로 호출할 수 있다.



**자바가 기본으로 제공**하는 `JDK 동적 프록시 기술`이나 `CGLIB` 같은 프록시 생성 오픈소스 기술을 활용하면 프록시 객체를 동적으로 만들어낼 수 있다. 



**실무에서 프록시를 적용할때는 인터페이스가 있는 경우가 있고 클래스만 있는 경우가 있다.** 

 `JDK 동적 프록시 기술`이나 `CGLIB`는 위 경우에 따라 동적 프록시를 생성하는 오픈소스 기술이다.



### JDK 동적 프록시

동적 프록시 기술을 사용하면 개발자가 직접 프록시 클래스를 만들지 않아도 된다. 

이름 그대로 프록시 객체를 동적으로 런타임에 개발자 대신 만들어준다. 그리고 동적 프록시에 원하는 실행 로직을 지정할 수 있다.

> JDK 동적 프록시는 인터페이스를 기반으로 프록시를 동적으로 만들어준다. 따라서 **인터페이스가 필수**이다.



### CGLIB

CGLIB는 바이트코드를 조작해서 동적으로 클래스를 생성하는 기술을 제공하는 라이브러리이다.

> CGLIB를 사용하면 인터페이스가 없어도 **구체 클래스만 가지고** 동적 프록시를 만들어낼 수 있다.





### 한계

대상 클래스가 100개라면 프록시 클래스도 100개를 만들어야했던 문제를

`동적으로 프록시 기술을 사용 `함으로써,  프록시 클래스 1개만 정의하고  **동적으로 대상을 적용**해서 그때그때 프록시를 만들어 사용할수있게되었다.

 

`JDK 동적 프록시는 인터페이스가 있는경우 사용하는 기술이고 CGLIB는 구체 클래스만 있는경우 사용`하는 기술이다.



**개발자가 일일이 경우에 맞게 JDK 동적 프록시나 CGLIB를 구분해서 사용해야할까?**



스프링이 제공하는 `프록시 팩토리`를 사용하면 스프링이 알아서 JDK 동적 프록시나 CGLIB를 사용해 프록시를 만들어 준다.





## 프록시 팩토리

개발자가 일일이 인터페이스가 있는 경우에는 JDK 동적 프록시를 적용하고, 그렇지 않은 경우에는 CGLIB를 적용해야 했던 문제를 해결하고 `프록시팩토리` 하나로 편리하게 동적 프록시를 생성할 수 있다.

![image-20220206142706295](C:\Users\afrad\AppData\Roaming\Typora\typora-user-images\image-20220206142706295.png)



JDK 동적 프록시를 사용할때 정의해야하는 `InvocationHandler` 와 CGLIB의 `MethodInterceptor`를 각각 중복으로 따로 정의해야 할까?



스프링은 이 문제를 해결하기 위해 부가 기능을 적용할 때 Advice 라는 새로운 개념을 도입했다.

> 개발자는 Advice 만 만들면 된다.
>
> `InvocationHandler` 나 `MethodInterceptor` 는 이 Advice 를 호출하게 된다.



또한, Pointcut이라는 개념을 도입해서 특정 조건에서만 프록시가 동적 생성되도록 할수있다.



### AOP 기초 맛보기

**Advice** 

> **부가기능**을 의미한다. ex) 프록시가 호출하는 부가 기능, 프록시 로직

**Pointcut**

> **어디에** 부가 기능을 적용할지, 어디에 부가 기능을 적용하지 않을지 판단하는 필터링 로직이다. 주로 클래스와 메서드 이름으로 필터링 한다. 이름 그대로 어떤 포인트(Point)에 기능을 적용할지 하지 않을지 잘라서(cut) 구분하는 것이다

**Advisor**

> 단순하게 하나의 포인트컷과 하나의 어드바이스를 가지고 있는 것이다. 쉽게 이야기해서 **포인트컷1 + 어드바이스1**이다.



**쉽게 기억하기**

부가기능( Advice )을 어디( Pointcut )에 할 것인가?

Advisor는 어디( Pointcut )에 부가기능( Advice )을 해야할지 할지 알고 있다.



**프록시 팩토리 동작구조**

![image-20220207132310944](C:\Users\afrad\AppData\Roaming\Typora\typora-user-images\image-20220207132310944.png)



**프록시 팩토리는 프록시를 생성할때 Advisor를 가지고 어디에 어떤 기능을 제공할지 알수있다.**

> 여러개의 어드바이저를 적용할 수 도있다.

~~~java
ServiceInterface target = new ServiceImpl();
//본 객체 target 넘겨받음
ProxyFactory proxyFactory = new ProxyFactory(target);
//어드바이저 생성
DefaultPointcutAdvisor advisor = new DefaultPointcutAdvisor(Pointcut.TRUE, new TimeAdvice());
//프록시 팩토리에 어드바이저 추가
proxyFactory.addAdvisor(advisor);
//프록시 팩토리로 생성된 프록시 get
ServiceInterface proxy = (ServiceInterface) proxyFactory.getProxy();
//프록시를 통해 본 객체 호출
proxy.save();
proxy.find();
~~~



**어드바이저**는 프록시 로직에 해당하는 어드바이스(여기선 로그를 찍는 코드)와 어디에 적용할지 정해진 포인트 컷을 가지고있다.

클라이언트가 프록시에게 요청을 보낸다.

프록시 팩토리는 포인트 컷을 확인해 해당 요청이 유효한지 확인한다.

포인트컷이 true를 반환하면 어드바이스를 호출해 부가 기능을 적용한다.

이후 실제 객체의 메서드를 호출한다.



**포인트 컷** 

포인트 컷을 생성하는 방법은 다양하다.

메서드 이름을 기반으로 지정할수도있고, Pointcut.TRUE와 같이 항상 참을 반환하도록 할수도있다.

하지만 실무에서는 **보다 정확하고 정밀한 포인트컷이 적용되어야 잘못 적용되는 일을 막을 수 있다.**

이때 **aspectJ 표현식** 이라는 것을 사용해서 포인트 컷을 생성한다.



**어드바이스**

포인트 컷이 참일때 적용할 로직을 정의한다.

여기에서는 로그를 찍는 로직일 것이다.



## 한계

이전에 대상 객체마다 프록시 객체를 생성하고 중복된 로직을 각 프록시에 모두 넣어야했다면

이제는 프록시 객체를 하나만 생성해두고 대상 객체를 주입해 동적으로 프록시를 만들수있다.

`프록시 팩토리` 를 이용해서  동적 프록시 기술인 JDK 동적 프록시나 CGLIB를 알아서 적용해서 동적으로 프록시를 생성할 수 있게 되었다.

이때, 어드바이저를 활용해 어디에 어떤 로직을 적용할지 편리하게 설정할수있다.



**하지만 문제가 있다.**



프록시를 사용하려면 본 객체 대신에 프록시 객체를 스프링 빈에 등록해야하는데

@Bean이 아닌 **컴포넌트 스캔**(@Component,@Controller,Service..etc) 를 사용해 **빈을 자동으로 등록**하는 경우는 

본 객체가 자동으로 등록되어버리기 때문에 프록시 객체를 대신 등록 할 수가 없다.



`빈 후처리기`를 사용하면 이를 해결 할 수 있다.





## 빈 후처리기

간단하게 표현해서 빈 등록과정을 조작하는 것이다.

이것은 스프링 빈 객체를 조작하거나 심지어 다른 객체로 바꾸어 버릴 수 있을 정도로 막강하다

**이 말은 스프링 빈 객체를 프록시로 교체하는 것도 가능하다는 뜻이다**



스프링이 제공하는 BeanPostProcessor 인터페이스를 구현해서 만든다.

~~~txt
빈 후처리기를 사용하려면 BeanPostProcessor 인터페이스를 구현하고, 스프링 빈으로 등록하면 된다.

postProcessBeforeInitialization: 객체 생성 이후에 @PostConstruct 같은 초기화가 발생하기 전에 호출되는 포스트 프로세서이다.

postProcessAfterInitialization: 객체 생성 이후에 @PostConstruct 같은 초기화가 발생한 다음에 호출되는 포스트 프로세서이다.
~~~

> 빈 후처리기 적용 시점을 결정 할 수 있다.



### 정리

`프록시 패턴`을 이용해서 핵심 로직으로 부터 서브 로직을 분리했고, 스프링이 제공하는 `동적 프록시 기술인 프록시 팩토리`를 이용해서 중복코드를 제거했다.

마지막으로 `빈 후처리기`를 이용해 컴포넌트 스캔으로 자동 등록된 본 객체를 프록시 객체로 바꿔치기함으로써 프록시를 효율적으로 사용할수있게 되었다.

**하지만 개발자의 욕심은 끝이 없다.**

스프링은 프록시를 생성하기 위한 **전용 빈 후처리기**를 <u>이미 만들어서 제공</u>한다.



## 스프링이 제공하는 빈 후처리기

~~~
implementation 'org.springframework.boot:spring-boot-starter-aop'
~~~

위 라이브러리를 추가하면 AOP 관련 클래스를 자동으로 스프링 빈에 등록한다. 

**AnnotationAwareAspectJAutoProxyCreator** 라는 빈 후처리기가 스프링 빈에 자동으로 등록된다.

이름 그대로 자동으로 프록시를 생성해주는 빈 후처리기이다.



개발자는 빈 후처리기를 따로 정의할 필요가 없다.



**AnnotationAwareAspectJAutoProxyCreator** 의 동작 과정을 살펴보자.

~~~
1. 생성: 스프링이 스프링 빈 대상이 되는 객체를 생성한다. ( @Bean , 컴포넌트 스캔 모두 포함)

2. 전달: 생성된 객체를 빈 저장소에 등록하기 직전에 빈 후처리기에 전달한다.

3. 모든 Advisor 빈 조회: 자동 프록시 생성기 - 빈 후처리기는 스프링 컨테이너에서 모든 Advisor 를 조회한다.

4. 프록시 적용 대상 체크: 앞서 조회한 Advisor 에 포함되어 있는 포인트컷을 사용해서 해당 객체가 프록시를 적용할 대상인지 아닌지 판단한다. 이때 객체의 클래스 정보는 물론이고, 해당 객체의 모든 메서드를 포인트컷에 하나하나 모두 매칭해본다. 그래서 조건이 하나라도 만족하면 프록시 적용 대상이 된다. 예를 들어서 10개의 메서드 중에 하나만 포인트컷 조건에 만족해도 프록시 적용 대상이 된다.

5. 프록시 생성: 프록시 적용 대상이면 프록시를 생성하고 반환해서 프록시를 스프링 빈으로 등록한다. 만약
프록시 적용 대상이 아니라면 원본 객체를 반환해서 원본 객체를 스프링 빈으로 등록한다.

6. 빈 등록: 반환된 객체는 스프링 빈으로 등록된다.
~~~



3번을 살펴보면 모든 Advisor 빈을 조회한다는것을 알수있다.



즉, 개발자는 Advisor 만 빈에 등록해두면 프록시를 사용할 수 있다.

> Advisor는 PointCut 과 Advice를 보유하고있기때문에 어떤 객체에 어떤 기능을 가진 프록시를 생성할지 알수있는것이다.



이때 여러개의 Advisor를 등록하더라도 같은 대상엔 하나의 프록시만 생성된다. Advisor당 프록시가 생성되는게 아니다.

> 프록시 팩토리가 생성하는 프록시는 내부에 여러 advisor 들을 포함할 수 있기 때문이다. 따라서 프록시를 여러 개 생성해서 비용을 낭비할 이유가없다.



### @Aspect 애노테이션을 사용해서 더 편리하게 포인트컷과 어드바이스를 만들수있다.



~~~java
@Component //빈 등록
@Aspect
public class LogTraceAdvisor {

    private final LogTrace logTrace;

    public LogTraceAdvisor(LogTrace logTrace) {
        this.logTrace = logTrace;
    }

    @Around("execution(* PU.puservice..*(..))") //포인트 컷 AspectJ 사용
    public Object execute(ProceedingJoinPoint joinPoint) throws Throwable { //Advice
        TraceStatus status = null;

        try { //로그 찍는 로직
            String message = joinPoint.getSignature().toShortString();
            status = logTrace.begin(message);

            //실제 대상 객체 로직 호출
            Object result = joinPoint.proceed();

            logTrace.end(status);
            return result;
        } catch (Exception e) {
            logTrace.exception(status, e);
            throw e;
        }
    }
}

~~~

> @Aspect : 애노테이션 기반 프록시를 적용할 때 필요하다. 어드바이저임을 의미
>
> @Around 의 값에 포인트컷 표현식을 넣는다. 표현식은 AspectJ 표현식을 사용한다.
>
> @Around가 붙은 메서드가 어드바이스( Advice )가 된다.
>
> @Component 를 이용해 어드바이저를 빈으로 등록한다.
>
> ProceedingJoinPoint joinPoint 자바 리플랙션 기술을 활용해 실제 호출 대상,전달인자 등에 대한 메타정보를 담고있다.



### 정리

스프링이 제공하는 프록시 전용 빈 후처리기를 사용해 어드바이저만 등록하여 편리하게 프록시를 사용할수있다.

