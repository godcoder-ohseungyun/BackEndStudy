# HTTP 이론

---



#### webStudy 레파지토리의 webCS 정리를 참고하며 복습하자



개발자는 평생 HTTP 기반위에서 개발한다. 언젠가 한번은 정리할 필요가 있다.

## [목차]

**[인터넷 네트워크](#인터넷-네트워크)**

> basic CS

**[웹 브라우저 요청흐름](#웹-브라우저-요청흐름-URI(Uniform-Resource-Identifier))**

> URL

**[HTTP란](#HTTP)**

> HTTP의 기초

**[HTTP 메서드](#HTTP-메서드)**

> GET POST ..

**[HTTP 상태코드](#HTTP-상태코드)**

> 404,504 ..에러들의 원인

**[HTTP 헤더](#HTTP-헤더)**

> 표현
> 협상
> 전송방식
> 정보
> 인증
> [**쿠키**](#[중요!!]6.쿠키헤더)
> **[캐시](#[중요!!]7.캐시헤더)**









# 인터넷 네트워크

---

![인터넷 프로토콜 계층](https://user-images.githubusercontent.com/68331041/127839070-ba11b2ef-8be4-4af8-816c-b7ee79a4cec2.PNG)

* **프로토콜::** 복수의 컴퓨터 사이나 중앙 컴퓨터와 단말기 사이에서 데이터 통신을 원활하게 하기 위해 필요한 통신 규약. 신호 송신의 순서, **데이터의 표현법**, 오류(誤謬) 검출법 등을 정함.

![프로토콜 계층](https://user-images.githubusercontent.com/68331041/127839078-a3196b84-b7b4-45ea-b3b3-2c96eda6c78c.PNG)

+ 각 계층에서 필요 정보를 패킷을 패키징하여 넘겨줌



## OS계층 프로토콜**(TCP,IP)**

---

+ SOCKET으로 부터 받은 데이터를 TCP/UDP 프로토콜에서  패키징하여  포트 정보(아파트 동 호수)를 주입하고 IP 프로토콜에서 IP주소(아파트 이름)를 주입하여 서버로 전송한다.



## IP(인터넷 프로토콜)

+ 출발지 IP, 목적지 IP 패키징

> 출발 IP와 도착 IP를 가지고 데이터를 던져서 여러 인터넷 망을 거쳐 다니며 도착지를 찾아 패킷을 전달한다.
>
> **문제:** 따라서 도착IP가 **존재하지 않아도 패킷이 전송**되며, 중간에 거쳐가던 망이 문제가 생기면 **데이터 중도 손실**될 위험이 있으며, 패킷마다 도착IP를 발견할 속도가 다르기 때문에 **순서에 맞지않게 패킷들이 도착** 할 수 도있다.

## TCP/UDP(전송 제어 프로토콜)

#### **인터넷 프로토콜의 문제점을 해결**

+ 출발지 PORT, 목적지 PORT
  전송 제어, 순서, 검증 정보 패키징

> **TCP**
>
> > **3 way handshake**(클라이언트가 SYN(접속 요청) 을 보내고 서버가 ACK(요청 수락)+SYN 을 응답하고 다시 클라이언트가  ACK하여 연결을 완료한다.)을 통해 **연결을 먼저 확인**하고 패킷을 전송하며 서버와 전송된 데이터를 가지고 소통하며 **데이터 전송과 순서를 보장**한다
> >
> > > 참고:  ACK와 함께 데이터 전송 가능
> 
> **UDP**
>
> > 기능이 거의 없음 도화지 같은 프로토콜
>>
> > **사용자 정의적 프로토콜로 입맛에 맞추어서 최적화 하여 사용**한다. **(요즘 떠오름)**
> 
> ### PORT란
>
> + 아파트가 IP라면 포트는 동+호 로 세부 주소
>
> > 여러 서버와 연결되는경우 **같은 IP 내에서 프로세스 구분하여 관리**하도록 함
>>
> > 유튜브 게임 통화 등등 동시작업할때





# 웹 브라우저 요청흐름 URI(Uniform Resource Identifier)

---



+ 리소스 식별 통합방법
+ URI? URL? URN?
+ URI는 URL(로케이터(locator)), URN(이름(name))로 분류될 수 있다

> 리소스의 위치와 리소스 이름
>
> **URN 이름만으로 실제 리소스를 찾을 수 있는 방법이 보편화 되지 않음**

![URI](https://user-images.githubusercontent.com/68331041/127839067-6c5385df-5396-4a7e-ad13-b07e4895e2f0.PNG)

## URI는   URL과 같은 의미로 봐도 무방하다! 올바른 URL설계가 필요하다.



## URL전체 문법

ex)
https://www.google.com:443/search?q=hello&hl=ko

> **프로토콜**(https)
>
> > **프로토콜**: 어떤 방식으로 자원에 접근할 것인가 하는 약속 규칙
> > 예) http, https, ftp 등등
> > http는 80 포트, https는 443 포트를 주로 사용, 포트는 생략 가능
> > https는 http에 보안 추가 (HTTP Secure)
>
> **호스트명**(www.google.com)
>
> > 호스트명
> > **도메인명(DNS) 또는 IP 주소**를 직접 사용가능
> >
> > > 구글 or www.google.com
>
> **포트** **번호**(443)
>
> > 일반적으로 생략
>
> **패스**(/search)
>
> > 리소스 경로(path), 계층적 구조
>
> **쿼리** **파라미터**(q=hello&hl=ko)
>
> > key=value 형태
> > **?**로 시작, **&**로 추가 가능 ?keyA=valueA&keyB=valueB
> > query parameter, query string 등으로 불림, 웹서버에 제공하는 **파라미터**, 문자 형태
>
> **fragment**
>
> > html 내부 북마크 등에 사용(한 화면에서 이동 마크)
> > 서버에 전송하는 정보 아님



## 웹 브라우저 요청 흐름



**요청 메세지**

~~~js
https://www.google.com:443/search?q=hello&hl=ko
1.DNS: www.google.com 를 통해 서버 IP 주소를 조회한다(포트번호 생략가능)
2./search?q=hello&hl=ko 리소스 위치를 이용하여 원하는 HTTP 메세지를 생성한다.
3. HTTP요청 메세지
----
    GET /search?q=hello&hl=ko HTTP/1.1 //PATH에 존재하는 리소스를 GET해줘라
    Host: www.google.com //여기로 보낸다
    +기타 부가정보
----

~~~

## <img src="https://user-images.githubusercontent.com/68331041/127839074-adb3578b-068f-473b-bcda-62ca0a5bba84.PNG" alt="전송 흐름도" style="zoom:50%;" />

HTTP 메세지를 생성하고 소켓라이브러리를 통해 IP와 PORT를 지정해 연결해준다. 이후 패킷을 생성하여 인터넷으로 던져주면 패킷에 적힌 정보를 가지고 서버로 날아간다.

**응답 메시지**

~~~apl
HTTP/1.1 200 OK
Content-Type: text/html;charset=UTF-8
Content-Length: 3423

# 응답 데이터가 HTML 형식이다. 다른 타입들도 자유롭게 오고갈수있다.
<html>
 <body>...
 </body>
</html>
~~~

서버도 똑같이 응답 메시지를 만들어 TCP/IP씌워서 응답해준다.


# HTTP

---

### + + *HTTP*는  리소스들을 가져올 수 있도록 해주는 프로토콜(데이터 양식)입니다.  서버와 클라이언트 사이의 리소스 소통 양식.

**HTTP 메시지에 모든 것을 전송**
• HTML, TEXT
• IMAGE, 음성, 영상, 파일
• JSON, XML (API)
• 거의 모든 형태의 데이터 전송 가능
• 서버간에 데이터를 주고 받을 때도 대부분 HTTP 사용
• 지금은 HTTP 시대!

**기반 프로토콜**
• TCP: HTTP/1.1, HTTP/2
• UDP: HTTP/3



# HTTP는



### 클라이언트 서버 구조를 따른다

Request Response 구조
• 클라이언트는 서버에 요청을 보내고, 응답을 대기
• 서버가 요청에 대한 결과를 만들어서 응답

클라이언트와 서버가 독립적으로 동작하며 각자 동작에 집중할수있다.



### 무상태 프로토콜( 서버는 Stateless(무상태) 로 관리해야한다.)이다.

**서버가 클라이언트의 상태를 보존X**

• 장점: 서버 확장성 높음(스케일 아웃)
• 단점: 클라이언트가 추가 데이터 전송

**Stateful, Stateless 차이**

> **상태 유지:** 중복되는 정보를 서버에게 기억하게 한다.
>
> > **중간에 서버가 터지면? 문제발생 다른 서버를 대체하여 사용할수없다. 항상 같은 서버가 유지되어야 한다.**
>
> **무상태:** 클라이언트가 정보를 끝까지 모두 가지고 있다
>
> > **아무 서버나 호출해도 된다**
> >
> > ### [핵 중요!!!]
> >
> > • 갑자기 클라이언트 요청이 증가해도 아무 서버를 대거 투입할 수 있다.
> > • 무상태는 응답 서버를 쉽게 바꿀 수 있다. -> **무한한 서버 증설 가능**


**실무 한계**

> • 모든 것을 무상태로 설계 할 수 있는 경우도 있고 없는 경우도 있다.
>
> • 무상태 예) 로그인이 필요 없는 단순한 서비스 소개 화면
>
> • 상태 유지 예) 로그인
>
> • 로그인한 사용자의 경우 로그인 했다는 상태를 서버에 유지
>
> • 일반적으로 **브라우저 쿠키와 서버 세션등을 사용해서 상태 유지기능을 구현한다**
>
> • **상태 유지는 최소한만 사용**





## 비연결성이다

**HTTP는 기본이 연결을 유지하지 않는 모델**(연결을 한 작업이 끝나면 바로 끊어버리는 형식)

• 일반적으로 초 단위의 이하의 빠른 속도로 응답

• 1시간 동안 수천명이 서비스를 사용해도 실제 서버에서 동시에 처리하는 요청은 수십개 이
하로 매우 작음

• 연결을 바로바로 끊기 때문에 서버 자원을 매우 효율적으로 사용할 수 있음

**단점**

> **매번 TCP/IP 연결을 새로 맺어야 함** - 3 way handshake 시간 추가
>
> 웹 브라우저로 사이트를 요청하면 매번 HTML 뿐만 아니라 자바스크립트, css, 추가 이미지 등
> 등 수 많은 자원이 함께 다운로드
>
> 지금은 **HTTP 지속 연결**(Persistent Connections)로 **문제 해결**
>
> HTTP/2, HTTP/3에서 **더 많은 최적화**

### [핵중요!!]

* **HTTP 지속 연결**

  > 초기에 한 페이지를 보이기위해 HTML 뿐만 아니라 자바스크립트, css, 추가 이미지 등 
  >
  > 각각의 리소스당 연결->해제를 반복하였으나
  >
  > > 예를들면 HTML 받고 연결해제 -> HTML 작업중 CSS필요 -> 다시연결 ->해제 ->CSS작업중 JS필요
  > >
  > > ->다시연결 ->해제
  >
  > **한 전체작업의 전체 리소스가 모두 받아질때까지만 연결을 유지해두는 지속연결을 사용하여 비연결성의 문제를 개선**
  >
  > > 연결 -> HTML~JS모두 다운받을때까지 연결유지 -> 해제



### 서버는 항상 무상태와 비연결성을 가져야 한다!





## HTTP 메세지



**HTTP 메세지 구조**

~~~python
HTTP-message = start-line  #1. 시작라인
 			*( header-field CRLF ) #2. 헤더
			 CRLF #3.공백라인 (필수)
			 [ message-body ] #4.메세지 바디 //데이터 유형:html,xml,json
~~~

4계층으로 나누어진 공식 스펙



**1.시작 라인**

> HTTP 메서드 (GET: 조회)
>
> > **GET** /search?q=hello&hl=ko HTTP/1.1
> >
> > 종류: GET, POST, PUT, DELETE
> >
> > GET: 리소스 조회
> > POST: 요청 내역 처리
>
> 요청 대상 (/search?q=hello&hl=ko)
>
> > GET /search?q=hello&hl=ko **HTTP/1.1**
> >
> > 절대경로= "/" 로 시작하는 경로
>
> HTTP Version
>
> > GET /search?q=hello&hl=ko **HTTP/1.1**

**2.헤더**

> HTTP **전송에 필요한 모든 부가정보**
>
> **HOST정보**
>
> **기타 헤더들**
>
> 메시지 바디의 내용, 메시지 바디의 크기, 압축, 인증, 요청 클라이언트(브라우저) 정보, 
> 서버 애플리케이션 정보, 캐시 관리 정보...

**3.공백라인 (필수)**

> 한칸 띄고

**4.메시지 바디**

> HTML 문서, 이미지, 영상, JSON 등등 byte로 표현할 수 있는 모든 데이터
>
> **실제 전송할 데이터**





> HTTPS를 사용하면 암호화 하여 데이터를 보낼수있다. 
>
> 인증된 기관에서만 HTTPS를 사용할수있다.





# HTTP 메서드

---



## HTTP API 설계

URI는 리소스만 식별! 

• **리소스와 해당 리소스를 대상으로 하는 행위을 분리**

> 회원을 등록하고 수정하고 조회하는게 리소스가 아니다!
>
> **회원이라는 개념 자체가 바로 리소스다**. 

• 리소스: 회원

• 행위: 조회, 등록, 삭제, 변경에 따라 **HTTP메서드로 행위 분리**



## HTTP 메서드

**주요 메서드**

### • **GET**: 리소스 조회

> 서버에 전달하고 싶은 데이터는 
>
> #### **URL query(쿼리 파라미터, 쿼리 스트링)를 통해서 전달**
>
> 
>
> **메시지 바디를 사용해서 데이터를 전달**할 수 있지만, **지원하지 않는 곳이 많아서 권장하지 않음**
>
> 이미 있는 정보를 조회할때 주로 사용한다.
>
> GET으로 온 경우 서버는 캐싱을 한다.

### • **POST**: 요청 데이터 처리, 주로   "등록" 에 사용,  리소스 생성 

> #### **메시지 바디를 통해** **서버로 요청 데이터 전달**
>
> 서버는 데이터를 처리하는 모든 기능을 수행한다
>
> 서버에 큰 변화가 생기는 경우 POST를 쓴다
>
> 새로운 데이터를 서버에 저장시킬때 주로 사용한다 ex)게시물 등록

### • **PUT**: 리소스를 대체, 해당 리소스가 없으면 생성

> 리소스가 있으면 **완전 대체** 리소스가 없으면 생성 쉽게 이야기해서 덮어버림
>
> 클라이언트가 리소스 위치를 알고 URI 지정

### • **PATCH**: 리소스 부분 변경

> 기존 리소스를 완전삭제하고 보낸 리소스로 완전 대체 되어버리는 PUT과 달리 
>
> 기존 리소스 부분을 변경한다.
>
> 지원하지 않는 경우가 있다.

### • **DELETE**: 리소스 삭제



## POST는 무적이다. 위 메소드를 모두 대체하여 사용할수있다.



**기타 메서드**
• HEAD: GET과 동일하지만 메시지 부분을 제외하고, 상태 줄과 헤더만 반환
• OPTIONS: 대상 리소스에 대한 통신 가능 옵션(메서드)을 설명(주로 CORS에서 사용)
• CONNECT: 대상 자원으로 식별되는 서버에 대한 터널을 설정
• TRACE: 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트를 수행



## HTTP 메서드의 속성

![HTTP 메서드 속성](https://user-images.githubusercontent.com/68331041/127839058-27468b74-1817-470c-825d-c12e4298165c.PNG)

**안전**(Safe Methods)

> 호출해도 리소스를 변경하지 않는다.

**멱등**(Idempotent Methods)

> 연산을 여러 번 적용하더라도 결과가 달라지지 않는 성질 1X1=1
>
> 한 번 호출하든 두 번 호출하든 100번 호출하든 결과가 똑같다
>
> [멱등O]
>
> GET: 한 번 조회하든, 두 번 조회하든 같은 결과가 조회된다.
> PUT: 결과를 대체한다. 따라서 같은 요청을 여러번 해도 최종 결과는 같다.
> DELETE: 결과를 삭제한다. 같은 요청을 여러번 해도 삭제된 결과는 똑같다.
>
> [멱등X]
>
> **POST: 멱등이 아니다! 두 번 호출하면 같은 결제가 중복해서 발생할 수 있다**

**캐시가능**(Cacheable Methods)

> 응답 결과 리소스를 캐시해서 사용해도 되는가?
>
> GET



## HTTP 메서드 활용



### **클라이언트에서 서버로 데이터 전송**
데이터 전달 방식은 크게 2가지

> **• 쿼리 파라미터를 통한 데이터 전송**
> 	• GET
> 	• 주로 정렬 필터(검색어)
>
> **• 메시지 바디를 통한 데이터 전송**
> 	• POST, PUT, PATCH
> 	• 회원 가입, 상품 주문, 리소스 등록, 리소스 변경

### **클라이언트에서 서버로 데이터 전송**

4가지 상황

> ### **• 정적 데이터 조회**(파라미터 **불필요**)
>
> ​	 	이미지, 정적 텍스트 문서
>
> ### **• 동적 데이터 조회**(파라미터 **필요**)
>
> ​		주로 검색, 게시판 목록에서 정 렬 필터(**검색어**)
>
> ### **• HTML Form을 통한 데이터 전송**
>
> ​		회원 가입, 상품 주문, 데이터 변경
>
> ​		**GET & POST만 지원한다.**
>
> ​		**주의!** GET은 조회에만 사용! 
>
> ​		리소스 변경이 발생하는 곳에 사용하면 안됨!
>
> ​		POST는 메세지 바디에 데이터를 보내 주지만 **GET은 URL에 쿼리 파라미터에    		데이터를 담아서 보낸다.** **외부로 노출**되기때문에 POST를 써야한다. 
>
> ### **• HTTP API를 통한 데이터 전송**
>
>  		**HTML FORM을 사용하지않고** 데이터를 전송함
>
> ​		회원 가입, 상품 주문, 데이터 변경
> ​		**서버 to 서버**, 앱 클라이언트, **웹 클라이언트**(Ajax)
>
> ​		예) **React, VueJs 같은 웹 클라이언트와 API 통신**



#### GET은 URL에 데이터를 받아 전송하며 POST는 HTTP메시지 바디에 데이터를 받아서 전송한다. 따라서 GET은 전달되는 데이터가 URL에 그대로 표기되며 POST는 표기되지 않는다.

> GET도 메시지 바디에 보낼수있으나 지원되는 곳이 많지 않기 때문에 사용하지 X



# HTTP 상태코드

---

## 상태 코드
**클라이언트가 보낸 요청의 처리 상태를 응답에서 알려주는 기능**

• 1xx (Informational): 요청이 수신되어 처리중
• 2xx (Successful): 요청 정상 처리
• 3xx (Redirection): 요청을 완료하려면 추가 행동이 필요

> 구 URL 에서 신 URL로 바뀐경우 구 URL을 입력하면 서버가 신 URL 정보를 응답해
>
> 클라이언트가 자동으로 리다이렉트 해서 재요청하도록 하여 자동으로 신 URL로 이동한다.

• 4xx (Client Error): 클라이언트 오류, 잘못된 문법등으로 서버가 요청을 수행할 수 없음
• 5xx (Server Error): 서버 오류, 서버가 정상 요청을 처리하지 못함



# HTTP 헤더

---

**HTTP 전송에 필요한 모든 부가정보를 표시하는 부분**
• 예) 메시지 바디의 내용, 메시지 바디의 크기, 압축, 인증, 요청 클라이언트, 서버 정보, 캐
시 관리 정보...

• 표준 헤더가 너무 많음



## HTTP 구조 중 BODY

JSON,HTML,XML..등등의 데이터를 담을수 있다.

(message body)을 통해 표현 데이터 전달

메시지 본문 = 페이로드(payload)



####  헤더는 데이터를 해석할 수 있는 정보 제공



## HTTP 구조 중 헤더에 표기되는 내용



#### **1.표현헤더**

---

Content-Type: 표현 데이터의 형식 표기

Content-Encoding: 표현 데이터의 압축 방식 표기

Content-Language: 표현 데이터의 자연 언어 표기

Content-Length: 표현 데이터의 길이 표기



#### **2.협상헤더**

---

**클라이언트가 선호하는 표현 요청**(서버에게 맞춰달라고 최대한 양해를 구하는 느낌)

+ **이 헤더를 적용하면 클라이언트에게 더 적합한 데이터를 지원해줄수 있다.**

+ **데이터들간 우선순위를 표기하여 서버가 클라이언트에게 맞춰줄수없을때 우선순위를 보고 그나마 적합한 데이터를 보내준다.**

  > Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7 
  >
  > ex)  한국어 1 영어 0.9 독일어 0.5 요청 -> 서버(영어,독일어만 보유) -> 한국어가 없기 때문에 영어를 보내줌

  

Accept: 클라이언트가 선호하는 미디어 타입 전달 표기

Accept-Charset: 클라이언트가 선호하는 문자 인코딩 표기

> ex) 이 클라이언트에게는 한글로 보내주기 바람.

Accept-Encoding: 클라이언트가 선호하는 압축 인코딩 표기

Accept-Language: 클라이언트가 선호하는 자연 언어 표기



#### **3.전송방식헤더**

---

Transfer-Encoding
Range, Content-Range

**전송 방식 설명**

• 단순 전송: 데이터 전체 내용을 알때 해당 길이만큼 전송

> Content-Length 표기

• 압축 전송

> Content-Encoding 표기

• 분할 전송: 나누어 전송

> Transfer-Encoding: chunked
>
> Content-Range **표기하면 안됨** ,chunk마다 길이가 이미 있음

• 범위 전송: 원하는 범위만 전송

> Content-Range
>
> 필요한 부분만 데이터를 받을수있다.



#### **4.정보헤더**

---

**일반 정보**
• From: 유저 에이전트의 이메일 정보
• Referer: 이전 웹 페이지 주소
• User-Agent: 유저 에이전트 애플리케이션 정보(웹 브라우저 정보, 등등)
• Server: 요청을 처리하는 오리진 서버의 소프트웨어 정보
• Date: 메시지가 생성된 날짜



**특별한 정보**
• Host: 요청한 호스트 정보(도메인) **필수헤더**

> **Host(도메인) 정보가 있어야 서버에서 알맞는 데이터를 제공**할수있다.

• Location: 페이지 리다이렉션

> 웹 브라우저는 3xx 응답의 결과에 Location 헤더가 있으면, Location 위치로 자동 이동
> **(자동 리다이렉트 하기 위한 헤더)**

• Allow: 허용 가능한 HTTP 메서드 표기

• Retry-After: 유저 에이전트가 다음 요청을 하기까지 기다려야 하는 시간 표기



#### **5.인증헤더**

---

Authorization: 클라이언트 인증 정보를 서버에 전달
WWW-Authenticate: 리소스 접근시 필요한 인증 방법 정의



### **[중요!!]6.쿠키헤더**

---

Set-Cookie: 서버에서 클라이언트로 쿠키 전달(응답)
Cookie: 클라이언트가 서버에서 받은 쿠키를 저장하고, HTTP 요청시 서버로 전달



### **HTTP는 무상태(Stateless) 프로토콜이다.**

• 클라이언트와 서버가 요청과 **응답을 주고 받으면 연결이 끊어진다**.
• 클라이언트가 다시 요청하면 서버는 **이전 요청을 기억하지 못한다**.
• **클라이언트와 서버는** **서로 상태를 유지하지 않는다**



사용자 정보를 기억하도록 하려면??  모든 요청에 url에 사용자 정보 포함시켜 서버와 데이터를 주고받으면??

모든요청에 대하여 사용자 정보를 생성?? 낭비가 심해진다. 브라우저를 완전히 종료하고 다시 열면 모두 날아간다.



### **쿠키의 탄생!!**

웹 브라우저 내부에 쿠키 저장소가 있다.

**서버가** 쿠키에 **저장할 정보**를 Set-Cookie 헤더에 담아 **보내주면** **브라우저는 쿠키저장소**에 해당 데이터를 **저장**해둔다.

이후 **웹 브라우저는 서버에 요청을 보낼때마다** **쿠키 저장소를 뒤져**서 필요한 정보를 **서버에 보내**준다.

> 요청시 모든 쿠키를 보내기 떄문에 쿠키가 많아지면 네트워킹 부하가 심해진다.

**url에 데이터를 담아 보낼필요 없이** 쿠키를 통해 **간편하게 정보를 관리**할수있다.



#### **쿠키 사용처**
​	• 사용자 로그인 세션 관리
​	• 광고 정보 트래킹 (사용자 관심사 정보)

#### **쿠키 정보는 항상 서버에 전송됨**
​	• 네트워크 트래픽 추가 유발
​	• 최소한의 정보만 사용(세션 id, 인증 토큰)
​	• 서버에 전송하지 않고, 웹 브라우저 내부에 데이터를 저장하고 싶으면 웹 스토리지 (localStorage, sessionStorage)

#### **주의!**
​	• 보안에 민감한 데이터는 저장하면 안됨(주민번호, 신용카드 번호 등등)



#### **쿠키 - 생명주기**

• 세션 쿠키: 만료 날짜를 생략하면 브라우저 종료시 까지만 유지
• 영속 쿠키: 만료 날짜를 입력하면 해당 날짜까지 유지



#### **쿠키 - 도메인  - 경로  - 보안**

특정 도메인만 쿠키 접근이 가능하게 할수있다.

특정 경로만 쿠키 접근이 가능하게 할수있다.

쿠키 보안 방식을 결정할수있다.

> **Secure**
> • 쿠키는 http, https를 구분하지 않고 전송
> • Secure를 적용하면 https인 경우에만 전송
> **HttpOnly**
> • XSS 공격 방지
> • 자바스크립트에서 접근 불가(document.cookie)
> • HTTP 전송에만 사용
>  **SameSite**
> • XSRF 공격 방지
> • 요청 도메인과 쿠키에 설정된 도메인이 같은 경우만 쿠키 전송





#### **[중요!!]7.캐시헤더**

**캐시 헤더**

> **Cache-Control: 캐시 제어**
>
> > Cache-Control: max-age
> > 캐시 유효 시간, 초 단위(for 유연한 관리)
> >
> > • Cache-Control: no-cache
> > 데이터는 캐시해도 되지만, 항상 원(origin) 서버에 검증하고 사용
> >
> > • Cache-Control: no-store
> > 데이터에 민감한 정보가 있으므로 저장하면 안됨
> > (메모리에서 사용하고 최대한 빨리 삭제)
>
> Pragma: 캐시 제어(하위 호환)
> Expires: 캐시 유효 기간(하위 호환)
>
> **검증 헤더 (Validator)** 
>
> > **ETag** 
> >
> > **Last-Modified **
>
> **조건부 요청 헤더**
>
> > If-Match, If-None-Match: ETag 값 사용
> > If-Modified-Since, If-Unmodified-Since: Last-Modified 값 사용



## **캐시의 탄생**

**캐시가 없을 때**
• 데이터가 변경되지 않아도 **계속 네트워크를 통해서 데이터를 다운로드** 받아야 한다.
• 인터넷 네트워크는 매우 느리고 비싸다.
• 브라우저 로딩 속도가 느리다.
• 느린 사용자 경험

**브라우저에 캐시 저장소를 만든다 like 쿠키**



#### **이전에 했던 같은 요청이라면 캐시 저장소에서 서버응답을 대신하여 정보를 가져온다.**



**캐시 적용**

• 캐시는 유효기간이 존재한다.  **cache-control 헤더** ,  **서버에서 유효기간을 책정**해서 **브라우저 캐시 저장소에 넘겨준다**.

> 서버 응답 결과가 업데이트로 인해 달라질수있기때문에 일정 기간만 사용하게 해준다.

• 캐시 덕분에 캐시 가능 시간동안 **네트워크를 사용하지 않아도 된다**.
• 비싼 네트워크 사용량을 줄일 수 있다.
• 브라우저 **로딩 속도가 매우 빠르다.**
• 빠른 사용자 경험

#### **만약 캐시 유효기간이 지나면? 다시 데이터를 전부 다운받아야 할까?**

1. 서버에서 기존 데이터를 변경함
2. 서버에서 기존 데이터를 변경하지 않음

두가지 경우가 있을수있다.



**검증 헤더  Last-Modified 추가**

캐시 유효기간이 지나도 로컬에 캐시데이터가 존재하는데 요청시에 캐시헤더에 최근 수정일을 담아 보내면 서버는

자신의 응답이 기존 캐시데이터와 일치하는지 아닌지 **검증헤더에 표기된 최종 수정일을 기준**으로 판단한다.

1. 서버에서 기존 데이터를 변경함

   > 모든 데이터 전송(BODY 포함)

2. 서버에서 기존 데이터를 변경하지 않음 

   > **서버가 헤더만 담아서 응답해줌** 메시지 바디가 없어서 **네트워크 부하 감소**
   >
   > 전송 용량 **0.1M** (헤더 0.1M, 바디 1.0M)



데이터가 변경되지 않은경우 캐시를 이용하여 효율적으로 네트워크 부하를 관리할수있다.



#### **하지만 위 방법은 단점이 있다, 데이터를 수정해서 최근 수정 날짜가 다르지만, 같은 데이터를 수정해서 데이터 결과가 똑같은 경우는???**



**검증 헤더 ETag 로 문제 해결**

캐시용 데이터에 임의의 고유한 버전 이름을 달아둠

캐시 제어 로직을 **서버에서 완전히 관리**

> 데이터가 변경되면 이 이름을 바꾸어서 변경함

**진짜 단순하게 ETag만 보내서 같으면 유지, 다르면 다시 받기!**



## 프록시 캐시

![image](https://user-images.githubusercontent.com/68331041/127975633-2da5f11a-2742-4d75-a0c7-832c12d5548c.png)

**공용 캐시 라고 생각하면 이해하기 쉽다.** 다수의 브라우저 이용객들의 요청에 따라 캐시가 저장되기 때문에

ex) 이용율이 높은 사이트 일수록 캐시를 많이 보유하고있어 속도가 빠르다.

**Cache-Control**
캐시 지시어(directives) - 기타
• Cache-Control: **public** 
• 응답이 public 캐시에 저장되어도 됨
• Cache-Control: **private** 
• 응답이 해당 사용자만을 위한 것임, private 캐시에 저장해야 함(기본값)

• Cache-Control: s-maxage 
• 프록시 캐시에만 적용되는 max-age
• Age: 60 (HTTP 헤더)
• 오리진 서버에서 응답 후 프록시 캐시 내에 머문 시간(초)



### 공용캐시이기 때문에 프록시 캐시에 저장되어도  되는지 안되는지 헤더를 통해 표기해야한다. 사적 정보는 private로 설정하여 프록시 캐시에 저장되지 않도록 한다.



## 캐시 무효화

**Cache-Control: no-cache** 
• 데이터는 캐시해도 되지만, 항상 원 서버에 검증하고 사용(이름에 주의!)

**Cache-Control: no-store** 
• 데이터에 민감한 정보가 있으므로 저장하면 안됨
(메모리에서 사용하고 최대한 빨리 삭제)



![image](https://user-images.githubusercontent.com/68331041/127977315-05f66465-626e-4b65-82b8-9a722b0278f5.png)



**Cache-Control: must-revalidate** 

캐쉬 무효화 데이터는 프록시가 검증해선 안된다. 무조건 원서버에게 보내야하는데

만약 중간에 프록시 서버가 원서버에 접근 못하게 된경우 무조건 에러를 반환해야한다.

Cache-Control: no-cache 로 하게 되면 위 경우 프록시가 답할수도있다.

