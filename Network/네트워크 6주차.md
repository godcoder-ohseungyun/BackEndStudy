





# 전송 오류 복구

---

### 프로토콜 별 정보 전송 단위 명칭

IP ,UDP 프로토콜

> **데이터그램**

 TCP 프로토콜

> **세그먼트**



+ **IP나 UDP**는 간단한 전송 프로토콜로 **오류복구 기능을 제공하지 않는다**.
+ **대부분의 오류복구는 TCP**에서 제공하며 이루어진다.



### 세그먼트

![image](https://user-images.githubusercontent.com/68331041/135827949-56afce7c-41d8-40bd-a6d5-a902fec3a50e.png)

#### **세그먼트 오류**

세그먼트 훼손 : 훼손된 세그먼트 도착(Checksum으로 확인)

세그먼트 손실 : 세그먼트 미도착(중간 통신장치의 버퍼 오버플로우)



#### **세그먼트 수신 확인**

1.세그먼트 정상 수신 -> **수신확인(ACK) 세그먼트 회신**

> **ACK(acknowledgement)**
> 수신자가 데이터 세그먼트의 정상수신을 확인하기 위해 송신자에게 보내는 특수한 세그먼트



2.훼손 세그먼트 수신 -> 폐기 -> 미수신



3.세그먼트 미수신 -> 인지 불가

> **세그먼트 미수신 확인**
>
> 세그먼트 전송 후 **타이머**(timer) 개시
>
> 타이머 종료시까지 ACK 미도착



### 오류 세그먼트 복구 절차

1) 세그먼트 전송, 타이머 시작
2) 세그먼트 타이머 종료할 때까지 ACK 미도착
3) **세그먼트를 재전송하고 타이머 재시작**



# TCP, 세그먼트 오류 복구 기법

---

## Stop-and-Wait ARQ 기법

+  Automatic Repeat Request

**송신자**
1) 세그먼트 **송신 후** **복제본을 버퍼에 유지**
2) 재전송 타이머 시작
3) 타이머 종료 전 ACK **수신 시** 복제본 폐기, 타이머 종료
4) 타이머 종료 전 ACK **미수신 시** 세그먼트 재전송, 타이머 재시작

**수신자**
1) 정상 세그먼트 수신 시 ACK 회신

> **ACK 도 세그먼트의 일종**으로 송신 오류가 날수있다.
>
> **정상 수신시에도 수신자 ACK 송신오류로 미수신 처리 될수있다.**
>
> **이때 재전송**함

<img src="https://user-images.githubusercontent.com/68331041/135829826-83400bc1-46f3-41b5-8bd2-f8fd4eef05c3.png" alt="image" style="zoom:50%;" />

### 즉, ACK 송신 오류로 정상 수신된 세그먼트가 미수신 처리되었을때 중복 수신이 되는데 Stop-and-Wait ARQ 기법은 이를 구분할 방법이 없다.

> Stop-and-Wait ARQ with SN 로 **해결가능!**





---

## Stop-and-Wait ARQ with SN

+ 송신 세그먼트 해드에 SN을 넣어 넘버링을 한다 0 또는 1값.
+ **중복수신 구분가능**



<img src="https://user-images.githubusercontent.com/68331041/135831035-c399c5e9-0dd7-42aa-b07e-6d29e4f2cecf.png" alt="image" style="zoom:50%;" />

1. 0 번 세그먼트 정상수신

2. **1 번을 붙여셔 ACK 송신**

3. 이때 **전송오류 발생**

4. 송신자는 **미수신으로 인식**하고 **0번 세그먼트 재 송신**

5. 수신자는 N 번 세그먼트가 또 들어옴으로써 **중복수신임을 눈치채고 구분가능** 



### SN에 0과 1 즉 1비트만 사용해도 충분히 중복수신 구분이 가능하다.



### 문제점 : 낮은 링크 사용 효율성

> **ACK가 도착할 때까지 전송 대기** -> 대기때문에 링크성능 만큼 전송을 할수없다.
>
> **대기 시간 동안 링크 미사용** -> 링크 사용률 저하



## Stop-and-Wait 는 실제 네트워킹에 사용하기엔 부적합하다.





---

## 파이프 라이닝

+ ACK가 회신 되기전 RTT 동안 링크에 M개의 세그먼트를 전송

  > **RTT**:  ACK 도착까지 대기시간.

+ 링크 효율 제고(stop-and-wait 보다 M배 높은 효율)

<img src="https://user-images.githubusercontent.com/68331041/135836604-78dd4778-8faa-461b-8e33-3b5efd82504e.png" alt="image" style="zoom:50%;" />

+ SN에 0,1만 사용하지 않는다. 0,4   1,5   2,6  

> 최대 파이프 라이닝 M보다 큰 순서번호를 사용한다.



## Go-back-N ARQ 기법

+ 파이프 라이닝을 활용한 기법
+  **오류 세그먼트**부터 **이후**의 **모든 세그먼트 재전송**



1) ACK가 회신 되는 **RTT 동안** 링크에 최대 M개의 **세그먼트를 전송**하고 **버퍼에 유지**

2) **ACK 수신하면** 해당 세그먼트(첫번째 세그먼트)을 버퍼에서 제거하고 송신가능 순서번호 **범위를 1씩 이동** 

> 윈도우 슬라이딩

3) 세그먼트 재전송 타이머가 종료될 때까지 **ACK가 수신되지 않으면** 해당 세그먼트부터 송신 윈도우 의 모든 세그먼트 재전송

> **송신 윈도우(send window)**
> 송신가능 순서번호 범위
> 송신 후 버퍼에 유지되어야 할 세그먼트의 범위

**[전체 과정]**

![image](https://user-images.githubusercontent.com/68331041/135841790-37ddaf94-1791-41ea-8a31-3018989c353e.png)

**순서번호가 3비트 임으로 최대 송신 윈도우 크기는 7이다.**

> 송신윈도우 M=4 임으로  7 > 4 임으로 문제없다. 
>
> 최대 4개의 세그먼트를 RTT동안 보낼수있다. 
>
> SN필드크기 m=3 임으로 최대 슬라이딩 윈도우 크기는 7 
>
> > 2^3-1 = 7
>
> 즉, 0 1 2 3 4 5 6 **7** 0 1 2 3..순
>
> **M을 최대 송신윈도우 크기보다 작은 4로 설정**, 한번에 0 1 2 3 4 
>
> ACK가 수신되면 윈도우 슬라이딩하여 범위가 +1 
>
> >  0 1 2 3 4 -> 1 2 3 4 **5** 

**세그먼트 넘버 0123 전송 0,1번 ACK 수신** 

**윈도우 슬라이딩 후 4 5 넘버를 달고 세그먼트 2개 더 송신가능**

**전송중인 세그먼트는 2 3 4 5**

**2번세그먼트 로스로 인한 타임아웃**

**2번이후 전송사항 전부 패기(discard)**

**2345 재전송**



### SN필드크기 m  bit 일때  왜  ''최대 '' 송신윈도우 크기는  '' 2^m - 1 '' 이어야 하는가?

> ![image](https://user-images.githubusercontent.com/68331041/135845501-9e2e0705-43fd-47b0-952b-ccf84ff69a96.png)
>
> + m=2
> + M은 최대 송신윈도우크기인 3 이하 여야 한다. 
>
> > M은 RTT동안 보낼수있는 세그먼트 수
>
> 
>
> ### **왼쪽 그림  최대 송신 윈도우 크기  2^m - 1인 경우**
>
> 0 1 2 세그먼트가 **올바르게 송신** 되었으나 **ACK가 모두 오류가 났다고 가정**했을때 타임아웃이 발생하여 0 1 2 재전송
>
> 수신자는 ACK의 오류 여부를 모르기 때문에 당연히 다음 넘버인 **3을 기다리고있다가 0을 만남**
>
> 이경우 ACK 전송에 문제가 있었구나 하고 **재전송임을 인지할수있음**
>
> ### 오른쪽 그림 2^m인 경우
>
> 0 1 2 3 세그먼트 송신 모두 ACK 오류
>
> 수신자는 다음 세그먼트 넘버인 0 을 기다린다.
>
> 타인아웃으로 인한 재전송 0 1 2 3
>
> 이때 기다리던 다음 세그먼드 넘버 0 과 재전송된 세그먼트 넘버 0이 동일하다. **ACK 전송 오류를 잡아낼수 없음**
>
> 
>
> ## [정리!!]
>
> ### 세그먼트 넘버가 들어갈 SN필드 크기가 m bit일때  최대 송신 윈도우 수는 2^m-1임으로  송신윈도우 수는  2^m-1이하의 값을 가져야 한다.
>
> >  **SN필드가 3 bit** 라면 **최대 송신 윈도우 수는 7** 
> >
> > SN에 0 1 2 3 4 5 6 7 0 1 2.. 순의 넘버를 가질수있고 
> >
> > **송신 윈도우 수(M)은 7이하의 값**을 가져야 한다.
> >
> > + **M = 2^m일 경우 전송 오류를 구별할수없는 경우가 생긴다. 위 정리 참고**





**장점**
Stop-and-wait 대비 고효율성
간단한 수신자 버퍼 관리(다음 세그먼트 수신용 버퍼)

**단점**
오류 세그먼트 이후 도착한 정상 세그먼트 재전송
불필요한 재전송 회수 증가
링크 효율 저하