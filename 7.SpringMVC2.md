# SpringMVC2

---

+ 스프링 CRUD ~> **다양한 웹 백엔드 기술** ~> DB



**[목차]**

[타임리프](#타임리프)

> 기본 기능 및 스프링과 타임리프 연동 기능

[메시지,국제화](#메시지,국제화)

> 





## 타임리프

---

공식 사이트: https://www.thymeleaf.org/
공식 메뉴얼 - 기본 기능: https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html
공식 메뉴얼 - 스프링 통합: https://www.thymeleaf.org/doc/tutorials/3.0/thymeleafspring.html



+ **React , Vue 같은 템플릿 엔진 프레임워크**를 이용하여 **인터렉티브하게 만들수도있지만**

**백엔드 엔지니어는** JSP 나 **타임리프같은** **간단한 확인용 템플릿 엔진**을 사용하여 **편리하게** 백단 동작을 

**검증하는 용도**로만 쓰면 된다. 



### **타임리프 특징(템플릿 엔진)**

> **서버 사이드 HTML 렌더링 (SSR)**
>
> + 백엔드 서버에서 HTML을 동적으로 렌더링
>
> **네츄럴 템플릿**
>
> + 순수 HTML을 최대한 유지
> + th:문법 을 통해 동적과 정적 모두 갖는 HTML을 구성할수있다.
>
> **스프링 통합 지원**





### 타임리프 기본 기능

----



#### **1 컨트롤러로 부터 넘겨받은 data:  html에 적용**

> 타임리프 템플릿 메서드

~~~html
<li>th:text 사용 <span th:text="${data}"></span></li>
    
<li>컨텐츠 안에서 직접 출력하기 = [[${data}]]</li>
~~~



#### **2 변수 표현식**

+ **프로퍼티 접근법**

**Object**

> ~~~html
> <li>${user.username} = <span th:text="${user.username}"></span></li>
>  <li>${user['username']} = <span th:text="${user['username']}"></span></li> <li>${user.getUsername()} = <span th:text="${user.getUsername()}"></span></li>
> ~~~
>
> user의 프로퍼티(맴버변수,매소드) 접근 

**List**

> ~~~html
> <li>${users[0].username} = <span th:text="${users[0].username}"></
> span></li>
>  <li>${users[0]['username']} = <span th:text="${users[0]['username']}"></
> span></li>
>  <li>${users[0].getUsername()} = <span th:text="${users[0].getUsername()}"></span></li>
> ~~~
>
>  List에서 프로퍼티 접근

**Map**

> ~~~html
> <li>${userMap['userA'].username} = <span th:text="${userMap['userA'].username}"></span></li>
>  <li>${userMap['userA']['username']} = <span th:text="${userMap['userA']['username']}"</span></li>
>  <li>${userMap['userA'].getUsername()} = <span th:text="${userMap['userA'].getUsername()}"></span></li>
> ~~~
>
>  Map에서 userA를 찾고, username 프로퍼티 접근



#### 3 **기본 객체들**

+ 타임리프는 기본 객체들을 제공한다.

~~~html
${#request}
${#response}
${#session}
${#servletContext}
${#locale}
${param.paramData}
~~~

내부 정보들도 가져올수있다.



#### **4 유틸리티 객체와 날짜**

+ 문자, 숫자, 날짜, URI등을 편리하게 다루는 다양한 유틸리티 객체들을 제공한다



**유틸리티 객체 예시**
https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#appendix-b-expressionutility-objects





#### **5 URL 링크**

+ URL을 생성할 때는 @{...} 문법을 사용하면 된다

~~~html
<li><a th:href="@{/hello}">basic url</a></li>
 <li><a th:href="@{/hello(param1=${param1}, param2=${param2})}">hello query param</a></li>
 <li><a th:href="@{/hello/{param1}/{param2}(param1=${param1}, param2=${param2})}">path variable</a></li> <li><a th:href="@{/hello/{param1}(param1=${param1}, param2=${param2})}">path variable + query parameter</a></li>
~~~

> **단순한 URL**
> @{/hello} /hello
>
> **쿼리 파라미터**
> @{/hello(param1=${param1}, param2=${param2})}   **=>**  /hello?param1=data1&param2=data2
>
> > () 에 있는 부분은 쿼리 파라미터로 처리된다.
>
> **경로 변수**
> @{ /hello/**{param1}/{param2}** (param1=${param1}, param2=${param2}) } **=>** /hello/**data1/data2**
>
> > URL 경로상에 변수가 있으면 () 부분은 경로 변수로 처리된다. 
>
> **경로 변수 + 쿼리 파라미터**
> @{/hello/{param1} (param1=${param1}, param2=${param2}) } **=>** /hello/data1?param2=data2
>
> > 경로 변수와 쿼리 파라미터를 함께 사용할 수 있다.



#### **6 Literal**

+ 리터럴은 소스 코드상에 고정된 값을 말하는 용어이다

~~~html
리터럴
    문자: 'hello'
    숫자: 10
    불린: true , false
    null: null

<li>리터럴 대체 |hello ${data}| = <span th:text="|12 ${data}|"></span></li>
<li>리터럴 대체 |hello ${data}| = <span th:text="|hello ${data}|"></span></li>
~~~

> 문자 + 변수



#### **7 연산**

+ 연산도 사용할 수 있다.

~~~html
<!--삼항연산자-->
<li>(10 % 2 == 0)? '짝수':'홀수' = <span th:text="(10 % 2 == 0)? '짝수':'홀수'"></span></li>

<!--Elvis 연산자-->
<li>${data}?: '데이터가 없습니다.' = <span th:text="${data}?: '데이터가 없습니다.'"></span></li>
<li>${nullData}?: '데이터가 없습니다.' = <span th:text="${nullData}?: '데이터가 없습니다.'"></span></li>
~~~



#### **8 속성 값 설정**

**속성 설정**
th:* 속성을 지정하면 타임리프는 기존 속성을 th:* 로 지정한 속성으로 대체한다. 기존 속성이 없다면
새로 만든다.

~~~html
<input type="text" name="mock" th:name="userA" />
타임리프 렌더링 후:<input type="text" name="userA" /> <!--name 속성이 대체 되어짐-->
~~~

**속성 추가**

~~~html
th:attrappend = <input type="text" class="text" th:attrappend="class='large'" /><br/><!--class에 large 추가 ~> textlarge-->
th:attrprepend = <input type="text" class="text" th:attrprepend="class='large'" /><br/>

th:classappend = <input type="text" class="text" th:classappend="large" /><br/>

th:attrappend : 속성 값의 뒤에 값을 추가한다.
th:attrprepend : 속성 값의 앞에 값을 추가한다.

th:classappend : class 속성에 자연스럽게 추가한다. 알아서 띄어쓰기 사용해서 뒤에 붙여줌
~~~

**checked 처리**

~~~html
checked o <input type="checkbox" name="active" th:checked="true" /><br/>- checked x <input type="checkbox" name="active" th:checked="false" /><br/>

checked=false <input type="checkbox" name="active" checked="false" /><br/
~~~



#### **9 반복문**

~~~html
<!--객체 List 반복문: 배열,Map도 가능-->
<tr th:each="user : ${users}">
     <td th:text="${user.username}">username</td>
     <td th:text="${user.age}">0</td>
 </tr>


반복 상태 유지도 가능하다 userStat으로 반복문 관련 정보를 얻을수있다. (현재 인덱스 등)
<tr th:each="user, userStat : ${users}">
~~~



#### **10 조건문**

~~~html
<!--if-->
<span th:text="'미성년자'" th:if="${user.age lt 20}"></span>

<!--not if-->
<span th:text="'미성년자'" th:unless="${user.age ge 20}"></span>

<!--switch-->
<!--* 은 만족하는 조건이 없을 때 사용하는 디폴트이다. -->
<td th:switch="${user.age}">
     <span th:case="10">10살</span>
     <span th:case="20">20살</span>
     <span th:case="*">기타</span>
</td>
~~~



#### **11 블록**

+ 두 div 블럭이 묶여서 루프를 돈다

~~~html
<th:block th:each="user : ${users}">
    
     <div>
     사용자 이름1 <span th:text="${user.username}"></span>
     사용자 나이1 <span th:text="${user.age}"></span>
     </div>
    
     <div>
     요약 <span th:text="${user.username} + ' / ' + ${user.age}"></span> 
    </div>
    
</th:block>
~~~



#### **12 템플릿 조각**

+  th:fragment="copy"
+ th:insert 

를 이용하여 템플릿 조각을 조합시킬수있다.

템플릿 형태 자체를 넘겨서 구성시킨다.

ex) base.html 에 footer.html 의 일부분을 insert하여 완성시킬수있다.



#### **13 템플릿 레이아웃**

+ 레이아웃 개념을 두고, 그 레이아웃에 필요한 코드 조각을 전달해서 완성하는 것

  > 템플릿 형태 자체를 넘기기 보다 **tag** 코드들을 넘겨서 해당 태그들을 **적재 적소에  자유롭게 배치**할수있다. 





### 타임리프 & 스프링 통합

+ **타임리프 스프링 통합 메뉴얼**: https://www.thymeleaf.org/doc/tutorials/3.0/thymeleafspring.html

  > 타임리프는 스프링 없이도 동작하지만, **스프링과 통합을 위한 다양한 기능을 편리하게 제공**한다. 그리고 이런 부분은 스프링으로 백엔드를 개발하는 개발자 입장에서 타임리프를  선택하는 하나의 이유가 된다.

**스프링 통합으로 추가되는 기능들**

> 스프링의 SpringEL 문법 통합
>
> ${@myBean.doSomething()} 처럼 스프링 빈 호출 지원
>
> 편리한 폼 관리를 위한 추가 속성
>
> > th:object (기능 강화, 폼 커맨드 객체 선택)
> > th:field , th:errors , th:errorclass
>
> 폼 컴포넌트 기능
>
> > checkbox, radio button, List 등을 편리하게 사용할 수 있는 기능 지원
>
> 스프링의 메시지, 국제화 기능의 편리한 통합
>
> 스프링의 검증, 오류 처리 통합
>
> 스프링의 변환 서비스 통합(ConversionService)



### **스프링과 타임리프 통합하기**

기존엔 타임리프를 스프링 빈으로 등록하여 사용해야 했는데 스프링 부트는 이 모든걸 자동화 해준다. 그냥 사용하면 된다.



 ### 통합후 추가되는 기능들



#### **1 입력 폼 처리**

~~~~html
<form action="item.html" th:action th:object="${item}" method="post">
 <div>
     <label for="itemName">상품명</label>
     <input type="text" id="itemName" th:field="*{itemName}" class="formcontrol" placeholder="이름을 입력하세요">
 </div>
 ============================================================================ 
th:object : 커맨드 객체를 지정한다.
    
*{...} : 선택 변수 식이라고 한다. th:object 에서 선택한 객체에 접근한다.
    
th:field
HTML 태그의 id , name , value 속성을 자동으로 처리해준다.
~~~~

> th:object="${item}"  cotroller에서 model로 넘겨받은 value 커맨드 객체를 지정한다.
>
> th:field="{item.itemName}"  ~> th:field="*{itemName}" 으로 객체명. 생략 가능
>
> th:field 를 통해 id , name , value 속성을 자동으로 처리

#### th:object , th:field 덕분에 폼을 개발할 때 약간의 편리함을 얻었다.



#### **2 요구사항 추가**

+ 타임리프를 사용해서 폼에서 체크박스, 라디오 버튼, 셀렉트 박스를 편리하게 사용하는 방법

**체크박스** 

> 체크박스는 체크시 true **미체크시 아무데이터도 반환하지 않는다.**(false가 아님)
>
> 만약 체크했었다가 추후에 체크 해제하는경우? ~>  아무데이터도 넘어온게 없기때문에 **기존 true값을 유지해 버린다**. **(수정에 문제가 생김)**
>
> 히든 필드라는것을 사용하여 false를 반환하도록 할수있는데 매번 히든필드를 추가하기 귀찮다.
>
> **th:field** 속성을 이용하여 false가 넘어오도록 설정할수있다.

**체크박스 멀티**

+ **체크박스 목록도 컨트롤러 백단에서 다룬다!!!!! **
+ **#ids 를 사용하여 각 목록별 id를 생성 지정 한다.**

> ~~~java
> /*
> @ModelAttribute의 특별한 사용법
> 
> 등록 폼, 상세화면, 수정 폼에서 모두 서울, 부산, 제주라는 체크 박스를 반복해서 보여주어야 한다. 이렇게 하려면 각각의 컨트롤러에model.addAttribute(...) 을 사용해서 체크 박스를 구성하는 데이터를 반복해서 넣어주어야 한다.
> 
> @ModelAttribute 는 이렇게 컨트롤러에 있는 별도의 메서드에 적용할 수 있다.
> 이렇게하면 해당 컨트롤러를 요청할 때 regions 에서 반환한 값이 자동으로 모델( model )에 담기게 된다.
> 
> 물론 이렇게 사용하지 않고, 각각의 컨트롤러 메서드에서 모델에 직접 데이터를 담아서 처리해도 된다.
> */
> //Controller
> @ModelAttribute("regions")
> public Map<String, String> regions() {
>  Map<String, String> regions = new LinkedHashMap<>();
>  regions.put("SEOUL", "서울");
>  regions.put("BUSAN", "부산");
>  regions.put("JEJU", "제주");
>  return regions;
> }
> 
> //HTML
> <!-- multi checkbox -->
> <div>
>     
>  <div>등록 지역</div>
>     //루프
>  <div th:each="region : ${regions}" class="form-check form-check-inline">
>      <input type="checkbox" th:field="*{regions}" th:value="${region.key}" class="form-check-input">
>          
> //#ids: id를 생성해준다. 멀티 채크박스이기 때문에 각 채크박스의 id를 개별적으로 관리해야할 필요가 있다. #ids를 사용하면 value를 보고 아이디를 자동 생성해서 적용시켜준다.
>      <label th:for="${#ids.prev('regions')}"
>      th:text="${region.value}" class="form-check-label">서울</label> 
> </div>
> </diV>
> ~~~
>
> 

**라디오 버튼** & **셀렉트 박스**

+ 여러 선택지 중에 하나를 선택할 때 사용할 수 있다. 



## 메시지,국제화

---

+ 상품명이라는 단어를 모두 상품이름으로 고쳐달라고 하면 어떻게 해야할까?

> 하나하나 수정하지 않도록 **다양한 메시지를 한 곳에서 관리**하도록 하는 기능을 **메시지 기능**이라 한다.
>
> ~~~java
> //messages.properteis file
> item=상품
> item.id=상품 ID
> item.itemName=상품명
> item.price=가격
> item.quantity=수량
> ~~~
>
> 메시지에서 설명한 메시지 파일( messages.properteis )을 **각 나라별로 별도로 관리하면 서비스를 국제화** 할 수 있다.
>
> ~~~java
> //messages_en.propertis file 영어권 전용
> ...
> 
> //messages_ko.propertis file 한국 전용
> ...
> ~~~

한국에서 접근한 것인지 영어에서 접근한 것인지는 인식하는 방법은 HTTP accept-language 해더 값을 사용하거나 사용자가 직접 언어를 선택하도록 하고, 쿠키 등을 사용해서 처리하면 된다.







































