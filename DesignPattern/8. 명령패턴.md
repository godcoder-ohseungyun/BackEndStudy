# **명령패턴**

---

### 손님은 요리사에게 직접 주문하지 않는다. 손님은 알바생에게 주문하면 알바생이 알맞는 주문을 처리하여 요리사에게 전달한다.      손님(sender)  <느슨한 의존관계> 요리사(receiver) 

> 요리의 생성과정을 몰라도 된다. 
>
> 주문방식에 대해서 세밀하게 알 필요가 없다.
>
> 주문(명령)처리는 알바생이 손님의 간단한 요청을 가공하여 요리사에게 전달 처리한다.

+ **메소드 요청을 객체화 하고 캡슐화하여 다양한 요청 처리(파라미터 이용 등)를 할수있도록 하는 패턴.**

  > 클라이언트에게 전적으로 위임되던 요청정보를 코드화 할수있음
  >
  > 요청 로그 정보를 히스토리화 하기 좋음(큐,파일시스템에 저장)
  >
  > 요청의 취소기능을 제공할수있다
  >
  > 요청객체와 요청수행 객체 사이의 의존관계를 느슨하게 유지할수있음

+ **기존명령vs명령패턴**

> ~~~java
> 기존 명령 방법
> Sender -> Receiver //직접 Receiver 객체의 함수를 호출 및 파라미터를 이용하여 연산수행
> 
> 명령패턴
> Sender -> CommandManager -> Receiver //CommandManager를 활용하여 명령을 객체화 연산 대행
> ~~~
>
> > CommandManager는 다양한 Command 객체를 관리한다.

+ **패턴 구성**

> **command interface**: 구체적 명령 객체를 위한 interface, 보통 execute와 undo 메소드를 포함하고 있음 
>
> **concrete command:** 명령 처리자와 행동을 연결함. 처리자가 제공하는 메소드를 이용하여 실제 행동을 실행함. 구체적 명령은 처리자와 의존관계를 맺음 
>
> 실행자(**invoker**): 요청의 실행을 요구함. 보통 명령 객체를 유지함 
>
> 처리자(**receiver**): 요청을 수행하기 위해 해야 하는 기능이 구현되어 있는 객체. 어떤 종류의 객체도 처리자가 될 수 있음 
>
> ---
>
> **클라이언트(TestCode):** 구체적 명령 객체를 생성하고 처리자와 연결함. 실행자에게 명령의 실행을 요청함. 명령 객체를 생성하는 클라이언트와 명령의 실행을 요청하는 클라이언트는 서로 다를 수 있음
>
> ![image](https://user-images.githubusercontent.com/68331041/138986873-1e4585b5-5aaa-4c2e-8f42-a621a7b9a0bc.png)

+ **실제코드**

> ~~~java
> //command interface
> //concrete command들을 위한 공통리모컨 및 설계도 역할
> public interface Command {
> 	void execute();
>     void undo();
>  /**
>  undo method는 실행된 excute를 취하해야한다.
>  Map 자료구조를 통해 excute를 히스토리로 저장 -> undo로 실행취소 적용
>  단,명령 객체를 복제하여 저장해야한다.
>  */
> }
> ~~~
>
> ~~~java
> //receiver 
> //명령수행을 위한 정의가 포함된 객체: like 요리사
> public class RoomLight {
> 	public void on(){
> 		System.out.println("");
> 	}
> 	public void off(){
> 		System.out.println("");
> 	}
> }
> ~~~
>
> ~~~java
> //concrete command
> //특정 명령을 수행하는 명령객체 implements Command & has-a receiver
> 
> //concrete command1
> public class RoomLightOnCommand implements Command {
> 	private RoomLight light; //receiver has-a
> 
>  public RoomLightOnCommand(RoomLight light){ //dip
> 		this.light = light;
> 	}
>  //override
> 	public void execute() {
> 		light.on();
> 	}
>  //override
>  public void undo(){
>      light.off();
>  }
> } 
> 
> //concrete command2
> public class RoomLightOffCommand implements Command {
> 	private RoomLight light; //receiver has-a
> 
>  public RoomLightOffCommand(RoomLight light){ //dip
> 		this.light = light;
> 	}
>  //override
> 	public void execute() {
> 		light.off();
> 	}
>  //override
>  public void undo(){ 
>      light.on();
>  }
> } 
> //굳이 RoomLightOnCommand의 반대 행동을 하는 RoomLightOffCommand 도 만들어야 하나?
> /**
> 만들어야한다. undo란 가장최근에 실행된 명령을 취소하는 커멘드 이기때문에 undo 메소드 내용도 반대로 적용되야한다.
> */
> 
> //명령어가 인자를 필요로 하는경우
> ~~~
>
> ~~~java
> //invoker
> public class RemoteControl {
>  private Command[] onCommands = new Command[7];
>  private Command[] offCommands = new Command[7];
>  private Command undoCommand = new NoCommand();
> 
>  public SimpleRemoteControl(){
>      Command noCommand = new NoCommand();
>      Arrays.fill(onCommands, noCommand);
>      Arrays.fill(onCommands, noCommand);
>      undoCommand = noCommand;
>  }
>  /** NoCommand class: 빈 커멘드 객체
>  public class NoCommand implements Command {
> 		public void execute() {}
> 		public void undo() {}
> 	}
> 	//빈 커멘드 객체를 사용하면 Pressed 메서드들에서 예외처리 없어도 됨
>  */
> 
>  public void setCommand(int slot, Command onCommand, Command offCommand)    { … }
> 
>  public void onButtonWasPressed(int slot){
>      /**
>      if(onCommands[slot]!=null) //null 대신 빈 커맨드 객체를 활용, 예외처리 필요 x
>      */
>      onCommands[slot].execute(); //slot: 몇번째 버튼을 눌렀는지
>      undoCommand = onCommand[slot]; //undoCommand.undo(): 가장 최근 눌린 버튼객체의 undo
>  }
> 
>  public void offButtonWasPressed(int slot){
>      offCommands[slot].execute();
>      undoCommand = onCommand[slot]; 
>  }
> 
>  public void undoButtonPressed(){
>  	undoCommand.undo();
>  }
> } // Invoker
> //모든 명령어를 컨트롤하는 실행자 like 서빙직원
> ~~~
>
> ~~~java
> //client testCode
> class Client{
>  psvm(){
>      SimpleRemoteControl sr = new SimpleRemoteControl;
>      sr.setCommand(new RoomLightOnCommand(new Roomlight()));
> 
>      sr.buttonWasPressed() //client는 버튼을 누루기만하면된다 커멘드실행은 invoker에게 위임 -> receiver와의 느슨한 의존관계 
> }  
> }
> ~~~

+ 





## [막 타이핑]

---

리모컨에 버튼에 다양한 기기를 연동할수있어야한다.

조건문으로 사용하는것은 바람직하지않다 -> 코드수정 다수 발생 ocp!

리모컨(sender)과 기기(receiver) 사이에 중계자(command)를 두면?

> 원래는 요청자(sender)가 요청처리까지 담당했다. 
>
> 명령 패턴에서는 중계자를 통해 요청처리를 위임한다.
>
> receiver가 어떻게 요청을 처리하는지 깊게 알 필요가 없어진다.
>
> 느슨한 의존관계

리모컨(sender)는 요청 커멘드만 알면되고

중계자(command)에서 요청 커멘드에 맞는 처리를 대행한다.

기기(receiver)는 요청 처리를 정의하는 class



**commandManager**

> 기존의 undo 메소드는 실행과 반대되는 행동을 취하도록 재정의 되었는데 스택데이터로 관리하여 목록유지할수있다.

**스택 데이터로 undo목록과 redo목록을 유지** -> 처리

~~~java
//invorker 
public class CommandManager {
    private Stack<Command> undoStack = new Stack<>(); //스텍 데이터 관리
    private Stack<Command> redoStack = new Stack<>();
    
    public void execute(Command… commands){
        for(var command: commands){
            undoStack.push(command);
            command.execute();
        }
    	redoStack.clear();
    }
    //undo는 가장 최근에 실행된 명령을 취소해야하고
    public void undo() {
        if(!undoStack.isEmpty()) {
            Command command = undoStack.pop();
            redoStack.push(command);
            command.undo();
        }
    }
    //redo는 가장 최근 실횡된 취소명령을 복구한다. 단, 실행명령이 들어오면 redo는 초기화
    public void redo() {
        if(!redoStack.isEmpty()) {
            Command command = redoStack.pop();
            undoStack.push(command);
            command.execute();
        }
    }
}
~~~





가장 최근 명령이 아니라 자유롭게 stack안 목록을 undo하면? 아래 문제 발생가능



**undo의 문제점**

이전 상태등 파라미터를 저장하는 커맨드의 경우 데이터가 올바르지 않게 변경되는 문제가있다.

매번 새롭게 명령객체를 만들어서 처리해야한다.





**매크로 커맨드**는 가변인자+forEach로 유연하게 처리

~~~java
public class MacroCommand implements Command{
    private Command[] commands;
    
    public MacroCommand(Commands[] commands){
    	// public MacroCommand(Commands… commands){
    	commands = coms;
    }
    
    public void execute(){
        for(Command com: commands)
        com.execute();
        // Arrays.stream(commands).forEach(Command::execute);
    }
}
~~~





**receiver가 상태인자가 필요한 경우**

concrete command는 receiver를 보유하고있다

concrete command에서 파라미터 처리를 해서 receiver로부터 명령처리 

3가지 방법

방법1

~~~java
public class CeilingFanCommand
implements Command{
private CeilingFan fan;
private int prevSpeed;
private int fanSpeed;
public CeilingFanCommand( //concrete command 생성자 호출시 파라미터를 입력받기
CeilingFan fan, int fanSpeed){
this.fan = fan;
this.fanSpeed = fanSpeed;
} // 방법 1
public void execute(){
prevSpeed = ceilingFan.getSpeed();
fan.setSpeed(fanSpeed);
}
public void undo(){
fan.setSpeed(prevSpeed);
}
}
~~~



방법2

~~~java
public class CeilingFanCommand
implements Command{
private CeilingFan fan;
private int prevSpeed;
private int fanSpeed;
public CeilingFanCommand(
CeilingFan fan){
this.fan = fan;
}
public void setSpeed(int fanSpeed){ //생성자가 x setter를 이용하여 파라미터 받기
this.fanSpeed = fanSpeed;
} // 방법 2
public void execute(){
prevSpeed = ceilingFan.getSpeed();
fan.setSpeed(fanSpeed);
}
public void undo(){
fan.setSpeed(prevSpeed);
}
}
~~~



방법3

~~~java
public class CeilingFanCommand
implements Command{
private CeilingFan fan;
private int prevSpeed;
private int fanSpeed;
public CeilingFanCommand(
CeilingFan fan){
this.fan = fan;
}

public void execute(int fanSpeed){ //방법3. execute가 매개변수를 가짐
prevSpeed = ceilingFan.getSpeed();
fan.setSpeed(fanSpeed);
}
public void undo(){
fan.setSpeed(prevSpeed);
}
}//공통화 개판
~~~



3다 단점이 있는 방법임 그나마 1번,2번이 나음 > 2번이 좀더 가변스러운듯?





**추가사항**

명령을 큐에 저장해두고 쓰래드를 이용해 동시에 여러 명령어를 실행하도록 할수있다.

파일시스템에 명령어적용 상태를 저장해두었다가 그대로 load할수있다.



**관련 리펙토링**

조건문에따라 처리가 달라지는 부분이 많은 코드는 명령패턴을 이용하는것이 옳다





**패턴의 특성: Behavior** 

**패턴의 수준: Component** 

**Applicability**

 요청을 하는 소스와 그 요청을 실제 실행하는 객체를 decoupling하기 위해 

실행된 행위에 대한 undo 기능, 실행된 행위를 저장한 후 재실행하는 기능이 필요할 때

 요청을 큐에 유지하고 나중에 실행할 필요성이 있을 때 

**장점** 

Command 객체를 여러 객체가 공유할 수 있음 

실행 시간에 command와 receiver를 변경할 수 있음 

새로운 command를 만들기 쉬움 

Macro command를 만들기도 쉬움