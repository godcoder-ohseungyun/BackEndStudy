

# 트랜스포트 계층(Transport Layer) 

---

+ 네트워크 계층 MD 읽고 오기

  

## 트랜스포트 계층 (대표 프로토콜: TCP,UDP)

![image](https://user-images.githubusercontent.com/68331041/134859894-8df2f19b-7b43-4990-ba8f-89d8cabec86e.png)

+ IP영역 즉, **네트워크 계층 서비스를 포괄** 
+ **NIC(HOST장치)내 Application** 끼리의 데이터 통신을 담당



#### 트랜스포트 계층 역할

> ### **다중화**
>
> > **데이터를 ''패킷으로 나누어'' 네트워크 계층에게 전달**, 네트워크 계층은 패킷을 전송하게 하는것
> >
> > > **포트번호** 같은 **필요 정보를 포함**하여 **패키징**한다.
>
> ### **역다중화**
>
> > **패킷**들을 **데이터로 재 조립**하여 **어플리케이션들에게 전달**
>
> **무결성(Integrity) 확인**
>
> > 손상 여부 확인
>
> **신뢰 전송(Reliable Transfer)**
>
> > **오류 복구**(Error Recovery) : 손상 또는 손실 세그먼트 복구
> > **흐름 제어**(Flow Control) : 수신 버퍼 오버플로어(overflow) 방지
>
> **혼잡 제어(Congestion Control)**
>
> > 전송량 조절을 통해 네트워크 혼잡 상황 회피 및 해소



#### **트랜스포트 계층 대표 프로토콜 TCP vs UDP**

> ![image](https://user-images.githubusercontent.com/68331041/134861168-f1f93f78-1753-4bdb-be48-bbcf8b9fdf33.png)
>
> ## 통신 유형(TCP와 UDP차이)
>
> > ### 다중화 유형
> >
> > **연결형**(connection-oriented) : 통신 소켓간에 **1:1** 논리적 연결 설정
> >
> > > 프로토콜: **TCP**
> > >
> > > **연결된 소켓끼리만 통신**가능(**핸드셰이킹**)
> > >
> > > **UDP보다 안정성이 높음**
> >
> > **비연결형**(connectionless) : 통신 소켓간에 **1:N** 논리적 연결 설정
> >
> > > 프로토콜: **UDP**
> > >
> > > **소켓 연결 과정 없음**
> > >
> > > 연결되지 않아도 구분키를 통해 자유롭게 통신가능
> > >
> > > 신뢰전송을 구축하지 않는 대신 **빠르고 간결하게 데이터 전송가능**
> >
> > 
> >
> > ### 다중화 서비스
> >
> > > **서버**는 URL + **80 PORT**로 **잘 알려진 포트** 고정되어있다.
> > >
> > > **클라이언트**는 그때그때 **일시적인 포트**를 사용한다.
> > >
> > > 
> > >
> > > + **소켓**: 트랜스포트 계층이 제공하는 응용 프로세스 통신 통로 자료구조
> > > + **응용 프로세스 주소** : 소켓 주소(IP 주소 + 포트번호)



# UDP

---

## UDP서비스



**비연결형:::** TCP와 달리 통신이전에 **소켓간의 연결설정이 없다**. (**핸드 셰이킹** 과정이 없다.)

> 소켓간의 연결이 있어야만 통신할수있는 **TCP와 달리** **UDP는 독립적으로 통신**함으로
>
> **동시의 여러** 클라이언트가 서버와 **통신**하거나 그 반대도 가능하다. **N:1 / 1:N 통신**
>
> ### 멀티테스킹 통신에 사용됨



**빠르고 간결한 통신이 가능**

**서버는 고정된 포트를 사용함**으로  이런 서비스가 가능

응용 프로세스로부터 데이터가 **송신 소켓**에 전달되면, 송신 **UDP는 해당 데이터를 포함하는 UDP 데이터그램(Datagram) 생성** 각 데이터그램은 IP를 통해 **''독립적''으로 목적지 UDP 소켓에 전송**



### 작고 빠른 데이터가 요구되는 작업에서 사용된다.



![image](https://user-images.githubusercontent.com/68331041/135256202-7df27865-fb11-4d94-9186-31cd4bef6cf0.png)

+ TCP와 달리 **출발 포트 도착포트**와 무결성 조건을 검사하는 **첵섬 데이터**만 포함된다.

> **무결성 검사 책섬 :::** 데이터의 손상이나 잘못된게 없는지 검사한다.

+ **매우 간단한 양식**
+ **수신측**도 처리가 복잡하지 않아서 더 **빠른 응답 가능**



## 첵섬

+ 데이터 해싱
+ 메시지를 정해진 길이의 데이터 단위로 나눔
+ 보수 검사합을 이용해 무결성 검사

### 장점

>  **높은 오류 검출 능력**
>  단순함
>  **소프트웨어 구현에 적합**

### 단점

>  각 데이터 단위에서 발생하는 오류의 **합이 0이 되는 오류 검출 불가**
>  **첵섬을 변경하지 않는 오류 검출 불가**





# TCP

---

**1:1 소켓 연결**
연결 설정 과정(handshaking) 필요
서버 연결 소켓 : 서버 IP 주소와 서버 Port 번호 공유 가능
멀티캐스팅(multicasting) 지원 불가



#### **TCP 통신연결**

> + 소켓주소 = IP 주소 + PORT 번호
>
> ![image](https://user-images.githubusercontent.com/68331041/136798922-ec3f6a63-b137-4ecf-876b-6274b5e49c71.png)
>
> 소켓연결을 이용하여 전이중 통신이 가능하다.
>
> ![image](https://user-images.githubusercontent.com/68331041/136805267-97db8e85-f9ae-4ebd-b017-4f14d18c0d90.png)
>
> TCP는 데이터 전송을 바이트 스트림 형태로 전송한다.
>
> ![image](https://user-images.githubusercontent.com/68331041/136805784-63874611-ebf8-421a-b09d-22c8d3d3a29c.png)
>
> + 데이터를 여러개의 세그먼트로 생성하여 전송
> + 위으 서버 응용 프로세스는 필요한만큼의 세그먼트를 수신버퍼에서 수신하여 활용한다.
>
> 
>
> ### 소켓 연결 과정
>
> ![image](https://user-images.githubusercontent.com/68331041/136806152-a181b051-d8c4-45e8-85d5-1172e32e151b.png)
>
> > **1. 클라이언트: SYN세그먼트(싱크세그먼트)를 전송**
> >
> > > 순서번호 SN필드 순서번호 설정
> >
> > **2. 서버가 자원이 충분하면 연결수락 SYN + ACK 세그먼트 응답**
> >
> > **3. 클라이언트 ACK 세그먼트 응답**
> >
> > 
> >
> > **4. 전이중통신 가능**
> >
> > > 위 3단계 **3HAND SHAKE** **완료후 데이터 통신 가능**
>
> 
>
> ### 소켓 연결 해제 과정
>
> > <img src="https://user-images.githubusercontent.com/68331041/136808582-693ef5b3-e337-4f7d-86ca-4acc1a849a49.png" alt="image" style="zoom: 80%;" />
> >
> > + 연결 해제의 경우 4 핸드 셰이킹
> > + 양쪽 연결 해제



### TCP 세그먼트

> + 위 **트랜스포트 계층** 설명중 다중화 개념에서 **TCP 프로토콜**은 **Application 계층 Data를 패킷으로 나누어** **세그먼트로 만든다**고 했다.
>
> 
>
> + **헤더**(control information) 필드 + **데이터**(payload) 필드로 구성되어있다.
>
> 
>
> **[응용 계층 데이터가 전송되는 과정]**
>
> ![image](https://user-images.githubusercontent.com/68331041/137315584-928fe5eb-a713-440a-b14f-1bb8acf16666.png)
>
> ~~~
> DATA -> SEGMENTS -> DATAGRAMS -> FRAMES
> ~~~
>
> 
>
> **MTU:** 최대 전송 유닛으로 한번에 전송할수있는 데이터 크기가 최대 1500 byte라는 뜻
>
> **MSS(Maximum Segment Size)**
>
> > **TCP는** 응용어플리케이션 **데이터를 분할하여 세그멘테이션한다.**
> >
> > 이때 분할된 Data는 각 세그먼트의 Data 필드에 담기는데 이 세그먼트들의 Data 필드의 최대 크기를 MSS라고 한다. **TCP segment Data필드에 최대 크기**
>
> **[네트워크 계층에서 전송될수있는 최대 데이터 크기]**
>
> > **데이터그램**(IP 헤더 크기 + **세그먼트**(TCP 헤더 크기+ MSS)) **≤** **MTU**



### TCP 세그먼트 구조

> ![image](https://user-images.githubusercontent.com/68331041/136979940-d4b3247d-e98b-432d-8dc7-a76ec38f5700.png)
>
> **TCP 포트 번호(Port Number)**
>
> > HTTP SMTP 등 응용 프로토콜 식별
> >
> > 클라이언트 포트 번호 : 연결 설정 시에 임의의 포트 번호 할당(Ephemeral Port)
> > 서버 포트 번호 : 연결 설정 전에 미리 할당(Well-known Port)
> > 출발지(source) 포트 번호 : 세그먼트 송신자의 포트 번호, 16 비트
> > 목적지(destination) 포트 번호 : 세그먼트 수신자의 포트 번호, 16 비트
>
> **순서 번호(Sequence Number)**
>
> > Seq
> >
> > **시작 순서 번호(ISN)**는 연결 설정할때 정해진다.
> >
> > **ISN + 송신된바이트수**
> > ISN : 3,000, 송신된바이트수 : 1,000  순서 번호 = 4,000
> >
> > 세그먼트 번호가 아님
>
> **확인 번호(Acknowledgement Number)**
>
> > ACK
> >
> > 순서대로 수신된 세그먼트의 **마지막 순서번호의 다음 번호** : **기대 순서번호**
>
> **헤더 길이(Header Length)**
>
> > 헤더 필드 전체 길이
>
> **수신 윈도우(Receive Window) 크기**
>
> > 수신 TCP가 수신 가능한 데이터 크기(버퍼 여유 공간)
>
> **제어 플래그(Control Flags)**
>
> > URG : Urgent
> > ACK : Acknowledgement
> > PSH : push
> > RST : Reset
> > SYN : Synchronization
> > FIN : Finish
>
> **긴급 데이터 포인터(Urgent Data Pointer)**
>
> > 긴급 데이터 위치



## TCP 재전송 타이머 설정

+ TCP RTT를 알아야한다

>세그먼트 송신 후 ACK 수신까지 걸리는 시간
>네트워크 상태에 따라 가변적인 시간: 매번 다르다

**재전송 타이머 설정(TimeoutInterval)** = 추정RTT(EstimatedRTT) + 4*분산RTT 안전여분(4*DevRTT)

> **재전송 타이머가 지나면 누락데이터로 판단 재송신한다.**





