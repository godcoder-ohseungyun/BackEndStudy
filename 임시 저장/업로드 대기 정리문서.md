# AOP,SOA,MSA

---



# AOP

---

**개요**

회원 가입하는데 소요되는 시간을 측정하고 싶다.

<img src="https://user-images.githubusercontent.com/68331041/146516632-711f532d-c7f7-4055-bad6-fdda4f406295.png" alt="image" style="zoom:50%;" />

Controller에 join 메서드에 다음과같은 시간 측정 로직을 포함하였다.

그런데 사실 핵심로직 부분은 표시된 부분 뿐이다.

회원가입을 수행하는 핵심로직 이외에 시간 측정 로직이라는 부가로직이 추가되었다.

사실 해당 메서드는 핵심로직만 수행하면 된다.

> 부가 로직의 무분별한 추가는 SRP,OCP 등에 위반한다.



이렇게 핵심로직이 아닌 시간측정,트랜잭션,권한책크 등 **부가적인 로직을 인프라 로직**이라고 칭한다.

> 인프라 로직이란?
>
> 인프라 로직은 부가기능으로 애플리케이션 전 영역에서 발생한다.
>
> 따라서 중복코드가 발생하기 쉽고 유지보수가 힘들어진다.
>
> 핵심 로직과 함께 있는경우 핵심로직을 파악하기 힘들어진다.



어떤 프로그램에 다음과 같은 비즈니스 로직이 있다.

~~~
로그인 기능
글 작성 기능
글 삭제 기능
~~~

<img src="https://user-images.githubusercontent.com/68331041/146513988-ef76af7e-5eda-4731-ba51-a0c905855015.png" alt="image" style="zoom:50%;" />

각 비즈니스 로직은 이와 같은 인프라 로직들을 필요로한다.



이 인프라 로직은 횡단으로 묶이기 때문에 **횡단 관심사**로 분류된다.

<img src="https://user-images.githubusercontent.com/68331041/146514303-e7677fb4-06d7-4246-841f-9cd99b2f7080.png" alt="image" style="zoom:50%;" />



## AOP!

Aspect-Oriented Programming(관점 지향 프로그래밍)는 여기서 등장한다. 

Cross-cutting Concern(황단 관심사)를 이용하여 **핵심 관심사와 공통 관심사를 ''분리''**하여 프로그램의 모듈성을 증가시키는 프로그래밍 기법이다.

핵심 관심사에는 비지니스 로직이 해당되며, 

해당 **비지니스 로직의 영향 혹은 수정 없이**, 여러 모듈에서 사용할 수 있는 **공통 로직을 적용**하는 방법이다.

> AOP를 적용하면 핵심로직과 인프라 로직을 **별도로 코딩**할수있어 모듈성이 증가한다.
>
> AOP를 적용하면 여전히 **핵심로직에 집중**하며 인프라 로직도 추가할수있다.
>
> 해당 인프라 로직이 어떤 핵심로직에 적용되는지 **한눈에 파악**할수있다.



#### 스프링 필터, 인터셉터도 AOP의 일종이다.



### OOP와 AOP

AOP는 OOP를 보완하여 더욱 객체지향으로 설계할수있도록한다.



**AOP 용어**

+ 아래와 같은 용어들 외에도 아주 많다.

Target

> 부가 기능이 부여되는 대상
>
> 어떤 대상에 부가기능을 부여할 것인가

Advice

> 부여할 부가 기능
>
> 어떤 부가기능을 부여할 것인가
>
> > Before,AfterThrowing,After 등
> >
> > > 메서드 실행전, 익셉션 발생 후, 실행 후

Join point

> 어디에 적용할 것인가
>
> > **메서드**,필드,객체,생성자 등 (스프링에선 메서드에만 적용)

Point cut

> 실제 advice가 적용될 지점을 선정





## Reference

---

https://www.youtube.com/watch?v=Hm0w_9ngDpM

https://kingjakeu.github.io/springboot/2021/02/02/spring-aop/







## SOA  vs MSA

---

소프트웨어는 코드라는 형체가 있지만 보이지 않기 때문에 더 정확하고 명확한 아키택쳐 설계가 필요하다.



**개요**

모듈을 구현할때 서로 다른 서비스들이 존재하고 이런 **서비스들의 조합으로 모듈을 동작**시킨다. 

SOA와 MSA는 **모듈 재사용성** 보다 **서비스 수준의 재사용성**에 초점이 맞춰져있다.

단위의 차이가 존재한다.



### SOA( Service Oriented Architecture)

> + 서비스 지향 아키텍쳐
>
> **비즈니스 단위**를 서비스라는 단위로 조합, **서비스 단위**들을 조합하여 하나의 **에플리케이션**을 개발하는 소프트웨어 아키택쳐
>
> 느슨한 결합이 특징이며 이에 따라 다음과 같은 장점이 있다.
>
> **유연성:** 각 단위 요소의 느슨한 결합때문에 유연성을 가진다.
>
> **확장성:** 각 단위 요소를 쉽게 추가 및 수정 할수있다.
>
> **안정성:** 작은 단위를 디버깅하는게 쉽기때문에 안정성이 용이하다.
>
> 
>
> **ESB**
>
> SOA시스템은 서비스의 확장에 따라 규모가 커지게 된다.
>
> 서로 간의 의존성이 존재하기 때문에 서비스간의 수정 및 호출의 복잡성이 증가한다.
>
> 이는 업무 수행의 ''경직성''을 유발한다.
>
> 이를 해결하기 위해 모든 서비스들을 중앙 버스에 두고 통합 관리하며 서비스간 연결 복잡도를 해소한다.
>
> 이 역할을 하는 중앙 버스를 ESB라고 한다.
>
> > 스프링 디스패쳐 서블릿??





### MSA ( MicroService Architecture)

> + 마이크로 서비스 아키텍쳐
>
> 각 컴포넌트 별로 단일 프로그램을 만들어 여러 프로그램의 조합으로 에플리케이션을 구축하는 방법
>
> > 회원 프로그램 + 상품 프로그램 + 주문 프로그램
> >
> > API를 통해 각 프로그램끼리 통신
>
> <img src="https://user-images.githubusercontent.com/68331041/146627700-b8131b21-c0e2-41a3-8182-dd8a6c739007.png" alt="image" style="zoom:50%;" />
>
> 각 컴포넌트가 독립된 프로그램으로 개발되어 개별 서버를 가지고있음으로 부분적 확장이 가능하다.
>
> > 회원 트래픽이 많은경우 회원 서버만 증설
>
> **단점**
>
> 하나의 프로세스에서 통신하지 않고 서버간 API통신을 하기때문에 속도가 느리고, 통신을 위해 데이터 변환 과정에 오버해드가 발생하기도 한다.
>
> 뛰어난 숙련도를 요한다.



<img src="https://user-images.githubusercontent.com/68331041/146627823-714e3a7e-b74b-4d5a-bfd5-d51cf78d0d05.png" alt="image" style="zoom:50%;" />



## Reference

---

[CLIPSOFT](http://clipsoft.co.kr/wp/blog/마이크로서비스-아키텍처msa-개념/)

[SOA VS MSA - DevBegin - WebNORI Labs : IT기술과 문화를 연구합니다.](https://wiki.webnori.com/display/devbegin/SOA+VS+MSA#)





## XML,JSON,YAML

---

+ 정보를 주고 받는 데이터의 형식



### XML

~~~XML
<?xml version="1.0" encoding="euc-kr"?>
<furniture-list>
    <table type="B" class="보급형">
        <productName>XX 책상</productName>
        <drawer>4</drawer>
        <hasBookshelf>true</hasBookshelf>
        <hasLamp>true</hasLamp>
        <target>학생</target>
        <price>130000</price>
    </table>
    <chair class="고급형">
        <productName>듀오 의자</productName>
        <target>모두</target>
        <price>35000</price>
    </chair>
    <bed>
        <productName>에이스 침대</productName>
        <size>2</size>
        <target>모두</taget>
        <price>280000</price>
    </bed>
</furniture-list>
~~~

> 열림 태그과 닫힌 태그가 존재하기때문에 오타 등 일부 태그가 누락되더라도 나머지 데이터가 정상적으로 랜더링 된다.
>
> 때문에 안정성이 요구되는 경우 사용된다. 

### JSON

~~~json
{
    "name": "식빵",
    "family": "웰시코기",
    "age": 1,
    "weight": 2.14,
    "dog": [ 
    {"name": "식빵", "family": "웰시코기", "age": 1, "weight": 2.14},
    {"name": "콩콩", "family": "포메라니안", "age": 3, "weight": 2.5},
    {"name": "젤리", "family": "푸들", "age": 7, "weight": 3.1}
	]
}
~~~

> XML보다 간단하게 데이터를 나타낸 포맷
>
> 자바스크립트 객체 형태로 데이터를 나타낸다.
>
> > 배열,객체 사용가능
>
> 중간에 오타 등 코드가 유실되면 모든 코드가 랜더링 불가상태가 된다.
>
> 간단함이 요구되는 경우 활용되며 이 같은 특징 덕에 널리 사용되고있다.

### YAML

> 직관적으로 개발자가 보기 편하게 나타내는 데이터 포멧
>
> 들여쓰기나 개행이 필수적이다.
>
> 때문에 스프링이나 도커 등 파악해야하는 환경설정파일에 자주쓰인다.







## 텐서플로우

---

구글에서 공개한  라이브러리

> 라이브러리란? 
>
> 다른 사람이 쉽게 사용할수있도록 이미 완성되어있는 코드

머신러닝에 대한 깊은 지식이 있어야 짤수있는 코드를 미리 만들어 대중에게 제공함으로써

산업계에서 머신러닝을 활용할수있도록 함

> 꼭 머신러닝에만 국한되는것은 아님
>
> 유사한 라이브러리로 파이토치도 존재하지마 파이토치는 연구계에서 많이 쓰인다.



보통 파이썬코드로 바로 작성하지않고 주피터 웹툴을 사용해서 테스팅 후 작성한다.

> 일부만 테스팅 하는 등 편리한 테스팅이 가능





## Reference

---

https://www.youtube.com/watch?v=oy5BGW8D5wc





## WebServer , WAS

----

**서버는 여러가지 의미를 가진다.**

> 1. 서버는 컴퓨터이다. **물리적인 기계**,하드웨어
> 2. 같은 컴퓨터에서도 서비스를 해주느냐 제공받느냐에 따라 서버라고 부르기도 한다.
> 3. 어떤 컴퓨터로 하여금 서버 역할을 하도록 하는 **소프트웨어**를 서버라고 하기도 한다.



### 웹 서버와 웹 애플리케이션 서버의 차이점

**웹 서버**

<img src="https://user-images.githubusercontent.com/68331041/141705717-6210c4fa-c80d-47bd-a1a0-ef22708101df.png" alt="image" style="zoom:67%;" />

+ 주로 정적 리소스를 제공해 준다.
+ 웹 사이트를 위한 서버로 **아파치,NginX**라는 프로그램(소프트웨어)들이 대표적이다.



**웹 애플리케이션 서버**(WAS)

<img src="https://user-images.githubusercontent.com/68331041/141705730-23216f16-9bd8-49c1-99ff-9f31217a0b18.png" alt="image" style="zoom:67%;" />

+ WAS라고 불리며 단순히 리소스를 제공하기만 하는게 아니라 
+ 프로그램 코드를 이용해 로직을 수행하며 전문적으로 동적 HTML과 HTTP API(JSON)를 클라이언트에게 제공해준다.
+ 대표적으로 **톰캣**이 있다.
+ Spring boot는 톰캣를 내장하고있다.



사실 둘의 경계가 모호하다.

웹 서버도 WAS의 기능을 할수있고 WAS도 웹 서버의 기능을 할수있다.

> 둘다 정적 동적 처리가 다 가능하다.

단, 웹 서버는 정적 리소스를 제공하고 WAS는 애플리케이션 로직을 실행하는데 특화 되어있다고 생각하면 된다.



### 왜 웹 서버(아파치)와 WAS(톰캣)를 연동해서 사용하는지 ?

예를들어 WAS만 사용한다면 너무 많은 역할 담당,과부화,서버 다운의 문제가 발생한다.

![image](https://user-images.githubusercontent.com/68331041/141706142-2c926d85-7bff-4df5-84a3-10d968a0a49d.png)

+ **전단에 웹 서버**를 위치 시키고 **후단에 WAS**를 위치시켜 사용한다.

![image](https://user-images.githubusercontent.com/68331041/141706120-e8adf1a1-0e33-404d-a600-c1dd4a420f7c.png)

![image](https://user-images.githubusercontent.com/68331041/141706123-44dde4ec-c6da-4216-8e85-f235a9f1593e.png)

+ 효율적인 리소스 관리
+ 정적 리소스는 웹서버에게 애플리케이션 로직 처리는 WAS에게 전담시킨다.
+ 정적 리소스가 많이 사용되면 Web 서버 증설
+ 애플리케이션 리소스가 많이 사용되면 WAS 증설필요에 따라 
+ **reverse proxy**의 기능을 사용할수있다.

> 서버는 보안상 내부 로직,리소스 위치를 드러내지 않아야 한다.
>
> WAS가 로직을 처리하면 웹 서버(아파치)가 프록시의 역할을 한다. 클라이언트와 WAS 사이에서 데이터를 주고 받아준다. 

+ **road balancing**의 기능을 사용할수있다.

> 웹 기능이 커지고 WAS 서버가 추가 증설된 경우
>
> 웹 서버는 클라이언트의 여러 요청을 여러 WAS에게 적절히 분배하여 처리하도록 하는 역할을한다.
>
> 처리 성능 측면에서 뛰어나다.

+ 웹 서버는 WAS서버가 잘돌고있는지 검토하는 역할도 한다.

  > WAS 서버는 무겁고 복잡한 로직을 수행하기때문에 서버가 잘 죽는 단점이있다. 



### 정리

웹 서버와 WAS는 기능적으로 겹치는 부분이 많지만 보안이랑 운영에 뛰어난 웹 서버가 직접 클라이언트를 응대하고 WAS는 후단에서 동적 로직을 처리하는데 집중하는 것이다.



+ 아파치 와 NginX차이

> 아파치는 멀티쓰레드로 동작
>
> > 컨텍스트 스위칭 비용 발생
>
> NginX는 싱글쓰레드 비동기로 동작
>
> > 큰 규모의 요청에서 불리



## Reference

---

https://www.youtube.com/watch?v=Zimhvf2B7Es







# API

---



인터페이스: 기능을 활용하기 위한 제어장치

> HW: 모니터,키보드
>
> SW: 버튼,스크롤 등 ex)UI
>
> 직접 보이지 않는 영역: 기기과 기기간 소통



api: 소프트웨어가 다른 소프트웨어로부터 지정된 형식으로 요청하여 명령을 받을수있는 수단

> 네트워크간에 존재하는것 만은 아니고 로컬프로그램인  웹 브라우저는 webAPI를 통해 자바스크립트로 부터
>
> 특정 동작 명령을 받는다.
>
> 윈도우는 시스템이나 하드웨어에 대한 세세한 지식 없이도 소프트웨어를 짤수있도록 Windows API를 제공한다.
>
> "이 함수를 사용하면 윈도우가 이렇게 해준다. " 라는걸 알고 쓸수있다.



RestAPI: 프론트엔드 웹에서 서버에 데이터를 요청하거나, 모바일 앱에서 서버에 요청을 넣는 등

이런 서비스에서 널리 사용되는것

http 요청을 보낼때 어떤 uri와 method를 사용할지 개발자들 사이에 널리 알려진 일종의 약속이자 모범사례이다.

> 예전엔 SOAP이란 복잡한 방법을 사용했다고한다.
>
> uri는 명사만 사용



가장 중요한 특성은 각 요청이 어떤 동작이나 정보를 위한것인지 요청 모습 자체로 추론이 가능하다는것이다.

https://(사이트 도메인)/**class/2/students?sex=male**

처럼 요청 만으로 **2반 남학생 목록**을 요청한다는 사실을 대략 알수있다.

https://(사이트 도메인)/**apple/2/s?e=male**

이런식으로 마음데로 해도 동작하게끔 ui를 개조해서 만들면 똑같이 2반 남학생 목록을 가져오겠지만

개발은 여러사람이 참여하며 재사용하기 용이해야한다. 

> apple이 뭔데 미친놈아

rest api를 사용하지 않으면 다른 개발자나 이후 인수인계과정 이 api를 이용해서 다른 서비스를 만들때 많은 어려움을 줄것이다.



자원을 구조화 함께 나타내는 형태 구분자를 uri라고 한다.

자원의 조회 뿐아니라 crud가 필요하다.

 이때 http의 다양한 method를 사용한다. 

get 

post put: 바디가 존재한다.



이 method들은 딱히 기능이 제약된게 아니라 post로 다 crud기능을 사용할수도있지만

restful하게 api를 만들기 위해서는 method들을 목적에 따라 구분해서 사용해야한다,





## Reference

---

https://www.youtube.com/watch?v=iOueE9AXDQQ





# JVM, JRE, JDK

---





##  JVM(java virtual machine)

---

+ 자바 가상 머신
+ 머신이라고 하지만 프로그램이다.

**개요**

C,C++,JAVA와 같은 언어들은 인간을 위해 만들어 진것으로 이를 컴퓨터가 이해하도록 하려면 01로 이뤄진 기계어로 번역해야한다. 

C같은 컴파일 언어들은 컴파일러가 그 작업을 대신해준다.

그런데 컴퓨터들이 모두 같은 기계어를 쓰는것은 아니다.

> A컴퓨터는 읽을수있는 C코드가 B 컴퓨터에서는 해석되지 못한다.

이런 불편함을 해결하기 위해 JAVA는 JVM이라는 전담 통역센터를 만든것이다.



**JVM이란?**

자바로 코딩후 컴파일을 하면 바이트코드라는게 생성된다. 

> 사람이 쓰는 JAVA 코드에서 컴퓨터가 읽는 기계어의 중간단계라고 생각하자.

Hello.java를 코딩해서 javac(자바 컴파일러)로 코드를 컴파일하면 Hello.class가 생성 되는데 이 Hello.class가 바로 바이트 코드이다.

이 바이트 코드 파일을 JVM에게 가져다주면 그때그때 컴퓨터에 맞게 바이트 코드를 기계어로 번역해준다.

즉, JVM은 자바로 짜서 컴파일한 소프트웨어들이 JVM이 설치된 어떤 기기에서도 동작하도록 해주는 것이다.

따라서 WORA(Write One Run Anywhere)가 자바의 원칙인것이다.

> 어떤 기기든 바이트 코드를 돌릴려면 JVM만 준비하면 된다.







## JRE(java runtime environment)

---

+ 자바 런타임 환경

**개요**

컴파일 타임과 런 타임

> 컴파일 타임
>
> >코딩이 완료된후 실행 혹은 배포전에 기계어로 미리 번역하는 작업을 컴파일이라고 하고 
> >
> >컴파일하는 시간을 컴파일 타임이라고 한다.
>
> 런 타임 
>
> > 자바로 짠 소프트웨어가 컴파일 및 빌드가 완료된 다음 실행되는 시점을 런 타임이라고 한다.
> >
> > > 빌드란?
> > >
> > > 소스코드 파일을 실행가능한 소프트웨어 산출물로 만드는 일련의 과정
> > >
> > > 빌드 단계에 컴파일이 포함되어있다.

**JRE란?**

우리가 자바에서 제공하는 라이브러리(List,HashMap 등)을 사용할수있는 이유는 jar라는 파일 덕분인데, 

jar 파일을 열어보면 List.clas 등 자바 라이브러리들이 바이트 코드로 저장되어있다.

이렇게 널리 쓰이는 JVM에서 동작할 라이브러리들과 JVM을 세트로 묶어 설치되도록 하는게 JRE이다.

JRE가 JVM을 포함하고있기 때문에 JRE만 설치하면 어디서든 자바를 사용할수있다.



## JDK(java development kit)

---

+ 자바 개발 도구

**개요**

자바를 컴파일할때 쓰는 컴파일러 javac, 자바를 디버깅할때 쓰는 jdb  등 개발에 필요한 도구들과 JRE, JVM을 포함하는 종합 도구

JDK만 설치하면 JVM JRE 및 다른 개발 툴들을 모두 제공받을수있다.

**JDK란?**

JVM과 JAR 파일에 라이브러리들을 함께 제공하는 JRE를 포함하고 JAVAC,JDB등 다양한 개발에 필요한 도구들을 포함하여 한번에 제공하는 자바 개발도구를

JDK라고 한다.



